<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Zz_krystal的博客</title>
  <icon>https://www.gravatar.com/avatar/1ad029f2f06011f9e9672d44109a2987</icon>
  <subtitle>以梦为马不负韶华</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://winterfu.github.io/"/>
  <updated>2018-01-12T03:22:55.468Z</updated>
  <id>http://winterfu.github.io/</id>
  
  <author>
    <name>Winter Fu</name>
    <email>fuwinterdong@gmail.com</email>
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>排序（五）：shell排序</title>
    <link href="http://winterfu.github.io/2018/01/12/%E6%8E%92%E5%BA%8F5%EF%BC%9Ashell%E6%8E%92%E5%BA%8F/"/>
    <id>http://winterfu.github.io/2018/01/12/排序5：shell排序/</id>
    <published>2018-01-12T01:45:16.000Z</published>
    <updated>2018-01-12T03:22:55.468Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：希尔排序（Shell Sort)也称递减量排序算法，以其设计者希尔(Donald Shell)的名字命名，该算法由1959年公布。<br><img src="/2018/01/12/排序5：shell排序/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;shell排序是一种插入排序，它是直接插入排序算法的一种威力加强版。<br><a id="more"></a></p><h3 id="二、算法思想"><a href="#二、算法思想" class="headerlink" title="二、算法思想"></a><strong>二、算法思想</strong></h3><p>&ensp;&ensp;该算法的基本思想是：将待排元素序列切割成若干个子序列（由相隔某个“增量”（gap）的元素组成），然后对这些子序列分别进行直接插入排序，然后按照规则一次缩减增量再进行排序，待整个序列中的元素基本有序（gap足够小）时，再对全体元素进行一次直接插入排序，即可完成所有排序工作。</p><h4 id="1、算法图解"><a href="#1、算法图解" class="headerlink" title="1、算法图解"></a><strong>1、算法图解</strong></h4><p>&ensp;&ensp;以n=10的一个数列{49, 38, 65, 97, 26, 13, 27, 49, 55, 4}为例，演示其选择排序过程，示意图如下：<br>&ensp;&ensp;第一次的gap我们选择数组长度的一半：gap = 10 / 2 = 5<br> <img src="/2018/01/12/排序5：shell排序/f1.jpg" alt=""><br>&ensp;&ensp;其中，1A,1B，2A,2B等为分组标记，数字同样的表示在同一组，大写字母表示是该组的第几个元素， 每次对同一组的数据进行直接插入排序。即分成了五组(49, 13) (38, 27) (65, 49)  (97, 55)  (26, 4)这样每组排序后就变成了(13, 49)  (27, 38)  (49, 65)  (55, 97)  (4, 26)，下同。<br> 排序后的数组变成：{13, 27, 49, 55, 4, 49, 38, 65, 97, 26}<br>&ensp;&ensp;第二次gap = 5 / 2 = 2<br><img src="/2018/01/12/排序5：shell排序/f2.png" alt=""><br>&ensp;&ensp;第三次gap = 2 / 2 = 1<br><img src="/2018/01/12/排序5：shell排序/f3.jpg" alt=""><br>&ensp;&ensp;第四次gap = 1 / 2 = 0 排序完毕得到有序数组<br><img src="/2018/01/12/排序5：shell排序/f4.jpg" alt=""><br>&ensp;&ensp;注意：每个小分组的元素进行直接插入排序后，直接映射到原数组，发生交换就互换，否则还  保持原来的顺序。可以看到图中有两个相等数值的元素“5”，通过排序过程我们可以看到，这两个元素位置交换了，所以希尔排序是不稳定算法。</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; 根据上面的思路，不难写出shell排序的实现，首先我们用C/C++实现:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">void ShellSort(int array[], int n)</div><div class="line">&#123;</div><div class="line">    for (int gap = n &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1)</div><div class="line">    &#123;</div><div class="line">        for (int i = gap; i &lt; n; i++)</div><div class="line">        &#123;</div><div class="line">            int temp = array[i];</div><div class="line">            int j = i - gap;</div><div class="line">            </div><div class="line">            while (j &gt;= <span class="number">0</span> &amp;&amp; array[j] &gt; temp)</div><div class="line">            &#123;</div><div class="line">                array[j + gap] = array[j];</div><div class="line">                j -= gap;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            array[j + gap] = temp;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"></div><div class="line">def ShellSort(input_list):</div><div class="line"><span class="keyword">if</span> len(input_list) == <span class="number">0</span>:</div><div class="line">return []</div><div class="line">result = input_list</div><div class="line">n = len(result)</div><div class="line">gap = n <span class="comment">// 2</span></div><div class="line">while gap &gt; <span class="number">0</span>:</div><div class="line">gap <span class="comment">//= 2</span></div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(gap, len(result)):</div><div class="line">temp = result[i]</div><div class="line">j = <span class="selector-tag">i</span> - gap</div><div class="line">while j &gt;= <span class="number">0</span> and temp &lt; result[j]:</div><div class="line">result[j + gap] = result[j]</div><div class="line">j -= gap</div><div class="line">result[j + gap] = temp</div><div class="line">return result</div></pre></td></tr></table></figure><h3 id="三、时间空间复杂度及算法稳定性分析"><a href="#三、时间空间复杂度及算法稳定性分析" class="headerlink" title="三、时间空间复杂度及算法稳定性分析"></a><strong>三、时间空间复杂度及算法稳定性分析</strong></h3><p>&ensp;&ensp;可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。<br>&ensp;&ensp;Donald Shell 最初建议步长选择为 n / 2，并且对步长取半直到步长达到 1。虽然这样取可以比 O(n^2) 类的算法（直接插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。<br><img src="/2018/01/12/排序5：shell排序/f5.jpg" alt=""><br>&ensp;&ensp;<font color="red"><strong>比较</strong></font>在希尔排序中是最主要的操作，而不是交换。用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。</p><p>&ensp;&ensp;算法稳定性我们已经在上面的算法图解中提到过，shell排序是一种不稳定算法。</p><p>&ensp;&ensp;<strong>直接插入排序和shell排序的比较</strong>：</p><ul><li>直接插入排序是稳定的；而希尔排序是不稳定的。</li><li>直接插入排序更适合于原始记录基本有序的集合。</li><li>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。</li><li>希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。</li><li>直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。</li></ul><p>附注：上面希尔排序的步长选择都是从n/2開始，每次再减半，直在结束时1。事实上，它可能有另一个更有效的步骤选择，假定读者兴趣了解。看到壳牌排序步骤的描述维基百科：<a href="http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F" target="_blank" rel="external">http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F</a></p><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p>&ensp;&ensp;<a href="https://www.cnblogs.com/gcczhongduan/p/4593943.html" target="_blank" rel="external">https://www.cnblogs.com/gcczhongduan/p/4593943.html</a><br>&ensp;&ensp;<a href="https://www.61mon.com/index.php/archives/193/" target="_blank" rel="external">https://www.61mon.com/index.php/archives/193/</a><br>&ensp;&ensp;<a href="http://cuijiahua.com/blog/2017/12/algorithm_3.html" target="_blank" rel="external">http://cuijiahua.com/blog/2017/12/algorithm_3.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：希尔排序（Shell Sort)也称递减量排序算法，以其设计者希尔(Donald Shell)的名字命名，该算法由1959年公布。&lt;br&gt;&lt;img src=&quot;/2018/01/12/排序5：shell排序/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;shell排序是一种插入排序，它是直接插入排序算法的一种威力加强版。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序,shell" scheme="http://winterfu.github.io/tags/%E6%8E%92%E5%BA%8F-shell/"/>
    
  </entry>
  
  <entry>
    <title>字符串模式匹配</title>
    <link href="http://winterfu.github.io/2018/01/11/%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%8C%B9%E9%85%8D/"/>
    <id>http://winterfu.github.io/2018/01/11/字符串匹配/</id>
    <published>2018-01-11T01:41:24.000Z</published>
    <updated>2018-01-12T03:16:57.697Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：字符串和数组是两种最基本的数据结构，都是用连续内存分别存储字符和数字，数组常用来查找，字符串常见的问题以字符串匹配最为常见。<br><img src="/2018/01/11/字符串匹配/ppoi.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp; 字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，那我们想知道，里面是否包含另一个字符串”ABCDABD”？</p><p>&ensp;&ensp;其中，前者叫作目标串称作T，也就是待查找的字符串，后者称为模式串称作P，如果T中存在一个或多个模式为P的子串，就给出该串在T中的位置，称为匹配成功；否则匹配失败。<br><a id="more"></a></p><h3 id="二、算法详解"><a href="#二、算法详解" class="headerlink" title="二、算法详解"></a><strong>二、算法详解</strong></h3><p>&ensp;&ensp;关于字符串匹配的算法也有很多，接下来我们来依次介绍。<br><strong>蛮力算法（BF算法）</strong></p><h4 id="1、算法介绍"><a href="#1、算法介绍" class="headerlink" title="1、算法介绍"></a><strong>1、算法介绍</strong></h4><p>&ensp;&ensp;蛮力算法（Brute-Force)，简称BF算法，其核心思想是：从目标串T的第一个字符与模式串P的第一个字符开始比较，若相等，则继续对字符串进行后续的比较；否则目标串从第二个字符起与模式串的第一个字符重新比较。直至模式串中的每个字符一次和目标串中的一个连续字符序列相等为止，此时称为匹配成功，否则匹配失败。</p><h4 id="2、算法图解"><a href="#2、算法图解" class="headerlink" title="2、算法图解"></a><strong>2、算法图解</strong></h4><p>&ensp;&ensp;接下来我们将以图解的形式来说明这种算法：<br><img src="/2018/01/11/字符串匹配/f000.jpg" alt=""><br><img src="/2018/01/11/字符串匹配/f001.jpg" alt=""></p><h4 id="3、性能分析"><a href="#3、性能分析" class="headerlink" title="3、性能分析"></a><strong>3、性能分析</strong></h4><ul><li>假设模式串的长度是m，目标串的长度是n。</li><li>最坏的情况是每遍比较都在最后出现不等，即没变最多比较m次，最多比较n-m+1遍。</li><li>总的比较次数最多为m(n-m+1)，因此BF算法的时间复杂度为O(mn)。</li><li>BF算法中存在回溯，这影响到效率，因而在实际应用中很少采用。</li></ul><h4 id="4、具体实现"><a href="#4、具体实现" class="headerlink" title="4、具体实现"></a><strong>4、具体实现</strong></h4><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std</div><div class="line">int bfMatch(string target, string pattern) &#123;</div><div class="line">    int pos = -1;</div><div class="line">    int i = 0, j = 0, k = 0;</div><div class="line"></div><div class="line">    <span class="comment">// 在没找到匹配pattern的子串前，遍历整个target</span></div><div class="line">    while (-<span class="number">1</span> == pos &amp;&amp; <span class="selector-tag">i</span> &lt; (int)target.length()) &#123;</div><div class="line"></div><div class="line">        <span class="comment">// 将目标串和模式串逐一比对，如果有不同的则退出</span></div><div class="line">        while (j &lt; (int)pattern.length() &amp;&amp; target[i] == pattern[j]) &#123;</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (j &gt;= (int)pattern.length()) &#123; <span class="comment">// 如果模式串扫描完，说明目标串中含有这个子串</span></div><div class="line">            pos = k;</div><div class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// 反之，没有扫描完，则从目标串的下一个字符开始重新逐一比对</span></div><div class="line">            j = 0;</div><div class="line">            k++;</div><div class="line">            i = k;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    return pos;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void print(string target, string pattern, int index) &#123;</div><div class="line">    <span class="keyword">if</span> (-<span class="number">1</span> != index) &#123;</div><div class="line">        cout &lt;&lt; "[" &lt;&lt; pattern &lt;&lt; "] is in the Pos = " &lt;&lt; index &lt;&lt; " of [" &lt;&lt; target &lt;&lt; "]" &lt;&lt; endl;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        cout &lt;&lt; "[" &lt;&lt; pattern &lt;&lt; "] is not in the [" &lt;&lt; target &lt;&lt; "]" &lt;&lt; endl;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p><strong>KMP算法</strong><br>&ensp;&ensp;KMP算法全称是Knuth-Morris-Pratt算法，其命名规则是按照三个发明人的名字命名的，开头的那个K，没错！就是那个老头，著名的科学家Donald Knuth。<br>&ensp;&ensp;这种算法不太容易理解，相信很多同学看这个算法的时候都是一头雾水，什么“部分匹配”，“移位”什么的都是怎么计算移动的，没关系，接下来我们就通俗的讲解一下这个算法。</p><h4 id="1、部分匹配表"><a href="#1、部分匹配表" class="headerlink" title="1、部分匹配表"></a><strong>1、部分匹配表</strong></h4><p>&ensp;&ensp;我们首先来介绍一个概念“部分匹配表”，顾名思义就是部分上能够匹配上的字符记录表格。那么这个表示怎么产生的呢？那我们就要理解一下什么是“前缀”和“后缀”的概念。”前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。<br><img src="/2018/01/11/字符串匹配/f00.jpg" alt=""><br>&ensp;&ensp;”部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例：<br><img src="/2018/01/11/字符串匹配/f01.jpg" alt=""><br>&ensp;&ensp;”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。</p><h4 id="2、实例详解"><a href="#2、实例详解" class="headerlink" title="2、实例详解"></a><strong>2、实例详解</strong></h4><p>&ensp;&ensp;我们要在字符串<font color="red">“BBC ABCDAB ABCDABCDABDE”</font>中判断是否包含字符串<font color="red">“ABCDABD”</font>。我们将ABCDABD称之为<font color="red">搜索词</font>。<br><img src="/2018/01/11/字符串匹配/f1.jpg" alt=""><br>&ensp;&ensp;第一步：字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。<br><img src="/2018/01/11/字符串匹配/f2.jpg" alt=""><br>&ensp;&ensp;第二步：因为B与A不匹配，搜索词再往后移。就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。<br><img src="/2018/01/11/字符串匹配/f3.jpg" alt=""><br>&ensp;&ensp;第三步：接着比较字符串和搜索词的下一个字符，还是相同。<br><img src="/2018/01/11/字符串匹配/f4.jpg" alt=""><br>&ensp;&ensp;第四步：接着往下比较，直到字符串有一个字符，与搜索词对应的字符不相同为止。<br><img src="/2018/01/11/字符串匹配/f5.jpg" alt=""><br>&ensp;&ensp;第五步：这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。<br><img src="/2018/01/11/字符串匹配/f6.jpg" alt=""><br>&ensp;&ensp;第六步：一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。<br><img src="/2018/01/11/字符串匹配/f7.jpg" alt=""><br>&ensp;&ensp;第七步：怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。<br><img src="/2018/01/11/字符串匹配/f8.jpg" alt=""><br>&ensp;&ensp;第八步：已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数：</p><p><font color="red">移动位数 = 已匹配的字符数 - 对应的部分匹配值</font><br>计算可以得出搜索词应该向后移动6 - 2 = 4位。<br><img src="/2018/01/11/字符串匹配/f9.jpg" alt=""><br>&ensp;&ensp;第九步：因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。<br><img src="/2018/01/11/字符串匹配/f10.jpg" alt=""><br>&ensp;&ensp;第十步：因为空格与A不匹配，继续后移一位。<br><img src="/2018/01/11/字符串匹配/f11.jpg" alt=""><br>&ensp;&ensp;第十一步：逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。<br><img src="/2018/01/11/字符串匹配/f12.jpg" alt=""><br>&ensp;&ensp;逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。</p><h4 id="3、性能分析-1"><a href="#3、性能分析-1" class="headerlink" title="3、性能分析"></a><strong>3、性能分析</strong></h4><ul><li>假设模式串的长度是m，目标串的长度是n。</li><li>在KMP算法中求next数组的时间复杂度为O(m)，在后面的匹配中因目标串T的下标不用回溯，所以比较次数可记为n。</li><li>由此，得出KMP算法的总的时间复杂度为O(n+m)。 <h4 id="4、具体实现-1"><a href="#4、具体实现-1" class="headerlink" title="4、具体实现"></a><strong>4、具体实现</strong></h4></li></ul><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;string&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">const int MAX = 100;</div><div class="line">int next[MAX] = &#123;0&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 计算部分匹配表</span></div><div class="line">void getNext(string pattern) &#123;</div><div class="line">    int j = 0, k = -1;</div><div class="line">    next[0] = -1;</div><div class="line">    while (j &lt; (int)pattern.length() - <span class="number">1</span>) &#123;</div><div class="line">        if (-1 == k || pattern[j] == pattern[k]) &#123;</div><div class="line">            j++;</div><div class="line">            k++;</div><div class="line">            next[j] = k;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            k = next[k];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    return;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// KMP算法</span></div><div class="line">int kmpMatch(string target, string pattern) &#123;</div><div class="line">    int i = 0, j = 0, index = 0;</div><div class="line">    getNext(pattern); // 计算部分匹配表</div><div class="line"></div><div class="line">    while (<span class="selector-tag">i</span> &lt; (int)target.length() &amp;&amp; j &lt; (int)pattern.length()) &#123;</div><div class="line">        if (-1 == j || target[i] == pattern[j]) &#123;</div><div class="line">            i++;</div><div class="line">            j++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            j = next[j]; // 如果出现部分不匹配，获取跳过的位置</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (j &gt;= (int)pattern.length())</div><div class="line">        index = i - pattern.length(); // 匹配成功，返回匹配子串的首字符下标</div><div class="line">    <span class="keyword">else</span></div><div class="line">        index = -1; // 匹配失败</div><div class="line"></div><div class="line">    return index;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a><strong>参考资料</strong></h4><p>&ensp;&ensp;<a href="http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html" target="_blank" rel="external">http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html</a><br>&ensp;&ensp;<a href="http://www.cnblogs.com/jingmoxukong/p/4343770.html" target="_blank" rel="external">http://www.cnblogs.com/jingmoxukong/p/4343770.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：字符串和数组是两种最基本的数据结构，都是用连续内存分别存储字符和数字，数组常用来查找，字符串常见的问题以字符串匹配最为常见。&lt;br&gt;&lt;img src=&quot;/2018/01/11/字符串匹配/ppoi.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp; 字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，那我们想知道，里面是否包含另一个字符串”ABCDABD”？&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;其中，前者叫作目标串称作T，也就是待查找的字符串，后者称为模式串称作P，如果T中存在一个或多个模式为P的子串，就给出该串在T中的位置，称为匹配成功；否则匹配失败。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="字符串,查找,匹配" scheme="http://winterfu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2-%E6%9F%A5%E6%89%BE-%E5%8C%B9%E9%85%8D/"/>
    
  </entry>
  
  <entry>
    <title>剑指offer（八）：斐波那契数列的拓展</title>
    <link href="http://winterfu.github.io/2018/01/10/%E5%89%91%E6%8C%87offer-8%EF%BC%9A%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97%E7%9A%84%E6%8B%93%E5%B1%95/"/>
    <id>http://winterfu.github.io/2018/01/10/剑指offer-8：斐波那契数列的拓展/</id>
    <published>2018-01-10T08:03:03.000Z</published>
    <updated>2018-01-10T11:14:01.701Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：前面我们已经提到很多问题都可看作是斐波那契数列的应用，这也是面试官经常考察的，如何将一个问题抽象成已有知识可以解答的问题的能力。<br><img src="/2018/01/10/剑指offer-8：斐波那契数列的拓展/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp; 不少面试题都可以看成是斐波那契数列的应用，下面我们就来介绍一个实际的应用和解题思路。<br>刷题平台： <a href="https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;tqId=11161&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-跳台阶</a>，<a href="https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;tqId=11162&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网-变态跳台阶</a>，<a href="%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96">牛客网-矩形覆盖</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><ul><li>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li><li>一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。</li><li>我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？</li></ul><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;我们分别对于以上三道题目进行分析，给出解题思路。</p><ol><li>首先，对于第一道跳台阶的问题，首先我们考虑最简单的情况，只有一级台阶，显然只有一种跳法。如果有两级台阶，那就有两种：一种是分两次跳，每次跳一级；另一种是一次跳两级。更一般的情况，当有n级台阶（n&gt;2)的时候，第一次跳就有两种不同的选择：一是一次跳一级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，我们用f(n-1)表示；另外一种选择是一次跳两级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，也就是f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)，很显然斐波那契数列嘛！！</li></ol><p><img src="/2018/01/10/剑指offer-8：斐波那契数列的拓展/f1.jpg" alt=""></p><ol><li>这道题目我们可以看出与上一题目的改变就是，青蛙的会的跳法数和台阶数是一致的，但是这不完全是斐波那契数列，下面我们来分析一下：</li></ol><p>&ensp;&ensp;（1）假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1)；假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)；假定第一次跳的是3阶，那么剩下的是n-3个台阶，跳法是f(n-3)……假定第一次跳的是n-1阶，那么剩下的是1个台阶，跳法是f(1)； 假定第一次跳的是n阶，那么剩下的是0个台阶，跳法是1种；<br>&ensp;&ensp;（2）总跳法为: f(n) = 1+f(n-1) + f(n-2)+….+f(1)  （第一个1是跳n阶只有一种方法）<br>&ensp;&ensp;（3）根据（2）可以得出有一阶的时候 f(1) = 1 ；有两阶的时候可以有 f(2) = 1+f(1)=2；有三阶的时候可以有 f(3) = 1+f(2)+f(1)=4…依次内推，有n阶时f(n)=2^(n-1)。</p><p>&ensp;&ensp;很容易就可以归纳出来这里结论，更简单的来想一下：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况。</p><p>&ensp;&ensp;归纳出来了表达式，可以看出这是一个乘方形式，而且还是2的乘方，为什么是2的乘方我们那么开心呢？哦原来我们平时一直在用的计算机不就是二进制形式工作的吗，那我们还用循环或者递归实现么，显然拒绝时间开销，拒绝递归调用，位运算给我们提供了很好帮助，一行代码搞定：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">return  1&lt;&lt;--number;</div></pre></td></tr></table></figure><ol><li>下面来分析第三个问题，这个填充的问题应该很多同学小学的时候没少做这样的问题吧，但是当时我们并没有深入去了解这个问题，也没有总结这个题目背后的规律。我们把2<em>8的覆盖方法记为f(8)。用2</em>1的小矩形去覆盖大矩形时，很显然两种方法：横着、竖着。当竖着放时，右边还剩下2<em>7的区域，如下图所示，这种情况下覆盖方法记为f(7)。接下来考虑横着放的情况，当放在左上角时，左下角必须也放一个横着的小矩形，那么剩下2</em>6的区域，这种情况下的覆盖方法记为f(6)，因此f(8) = f(7)+f(6)，看又熟悉了吧，斐波那契数列啊！！！<br><img src="/2018/01/10/剑指offer-8：斐波那契数列的拓展/f2.png" alt=""></li></ol><h3 id="三-、总结"><a href="#三-、总结" class="headerlink" title="三 、总结"></a><strong>三 、总结</strong></h3><p>&ensp;&ensp;通过这几道题目的分析，我们可以得出一个结论：那就是要活学活用自己学到的知识，要学会举一反三，如何分析问题并将其抽象成我们已经掌握的知识可解决的问题，这种能力才是我们今后学习的过程中要不断提高加强的！！！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：前面我们已经提到很多问题都可看作是斐波那契数列的应用，这也是面试官经常考察的，如何将一个问题抽象成已有知识可以解答的问题的能力。&lt;br&gt;&lt;img src=&quot;/2018/01/10/剑指offer-8：斐波那契数列的拓展/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp; 不少面试题都可以看成是斐波那契数列的应用，下面我们就来介绍一个实际的应用和解题思路。&lt;br&gt;刷题平台： &lt;a href=&quot;https://www.nowcoder.com/practice/8c82a5b80378478f9484d87d1c5f12a4?tpId=13&amp;amp;tqId=11161&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网-跳台阶&lt;/a&gt;，&lt;a href=&quot;https://www.nowcoder.com/practice/22243d016f6b47f2a6928b4313c85387?tpId=13&amp;amp;tqId=11162&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网-变态跳台阶&lt;/a&gt;，&lt;a href=&quot;%E7%89%9B%E5%AE%A2%E7%BD%91-%E7%9F%A9%E5%BD%A2%E8%A6%86%E7%9B%96&quot;&gt;牛客网-矩形覆盖&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="递归,循环" scheme="http://winterfu.github.io/tags/%E9%80%92%E5%BD%92-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>排序（四）：选择排序</title>
    <link href="http://winterfu.github.io/2018/01/04/%E6%8E%92%E5%BA%8F4%EF%BC%9A%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/"/>
    <id>http://winterfu.github.io/2018/01/04/排序4：选择排序/</id>
    <published>2018-01-04T09:06:48.000Z</published>
    <updated>2018-01-04T11:09:30.228Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：选择排序（Selection Sort)是一种最简单直接的排序算法。<br><img src="/2018/01/04/排序4：选择排序/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;选择排序是一种简单直接的选择排序算法，每趟在未排序的数列中找到最小（或者最大）的元素，然后将其放在数列的起始（或末尾）位置。<br><a id="more"></a></p><h3 id="二、算法思想"><a href="#二、算法思想" class="headerlink" title="二、算法思想"></a><strong>二、算法思想</strong></h3><p>&ensp;&ensp;首先在未排序的数列中找到<font color="red">最小(or最大)</font>元素，然后将其存放到数列的<font color="red">起始(or末尾)</font>位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="1、算法图解"><a href="#1、算法图解" class="headerlink" title="1、算法图解"></a><strong>1、算法图解</strong></h4><p>&ensp;&ensp;以数列{20,40,30,10,60,50}为例，演示其选择排序过程，示意图如下：<br> <img src="/2018/01/04/排序4：选择排序/f1.jpg" alt=""><br> &ensp;&ensp;排序流程如下：</p><ul><li>第1趟：i=0。找出a[1…5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数组变化：20,40,30,10,60,50– &gt; 10,40,30,20,60,50</li><li>第2趟：i=1。找出a[2…5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数组变化：10,40,30,20,60,50– &gt; 10,20,30,40,60,50</li><li>第3趟：i=2。找出a[3…5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。</li><li>第4趟：i=3。找出a[4…5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。</li><li>第5趟：i=4。交换a[4]和a[5]的数据。 数组变化：10,20,30,40,60,50 – &gt; 10,20,30,40,50,60</li></ul><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; 根据上面的思路，不难写出选择排序的实现，首先我们用C/C++实现:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;vector&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="comment">// 简单选择排序</span></div><div class="line">vector&lt;int&gt; SelectSort(vector&lt;int&gt; list)&#123;</div><div class="line"><span class="comment">// 需要遍历获得最小值的次数</span></div><div class="line"><span class="comment">// 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列</span></div><div class="line">vector&lt;int&gt; result = list;</div><div class="line">for (int i = 0; i &lt; result.size(); i++)&#123;</div><div class="line"><span class="comment">// 用来保存最小值得索引</span></div><div class="line">int index = i;</div><div class="line"><span class="comment">// 用来保存最小值得索引</span></div><div class="line">for (int j = i + 1; j &lt; result.size(); j++)&#123;</div><div class="line"><span class="keyword">if</span> (result[index] &gt; result[j])&#123;</div><div class="line">index = j;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 将找到的第i个小的数值放在第i个位置上</span></div><div class="line">swap(result[i], result[index]);</div><div class="line">cout &lt;&lt; "第" &lt;&lt; i + 1&lt;&lt; "趟:\t";</div><div class="line">for (int i = 0; i &lt; result.size(); i++)&#123;</div><div class="line">cout &lt;&lt; result[i] &lt;&lt; " ";</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def select_sort(lists):</div><div class="line">    # 选择排序</div><div class="line">    count = len(lists)</div><div class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">0</span>, count):</div><div class="line">        min = i</div><div class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="selector-tag">i</span> + <span class="number">1</span>, count):</div><div class="line">            <span class="keyword">if</span> lists[min] &gt; lists[j]:</div><div class="line">                min = j</div><div class="line">        lists[min], lists[i] = lists[i], lists[min]</div><div class="line">    return lists</div></pre></td></tr></table></figure><h3 id="三、时间空间复杂度及算法稳定性分析"><a href="#三、时间空间复杂度及算法稳定性分析" class="headerlink" title="三、时间空间复杂度及算法稳定性分析"></a><strong>三、时间空间复杂度及算法稳定性分析</strong></h3><p>&ensp;&ensp;选择排序的时间复杂度是O(N2)：假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次因此，选择排序的时间复杂度是O(N2)。</p><p>&ensp;&ensp;选择排序需要占用一个临时空间，用于保存最小值的索引，所以空间复杂度是1.</p><p>&ensp;&ensp;选择排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：选择排序（Selection Sort)是一种最简单直接的排序算法。&lt;br&gt;&lt;img src=&quot;/2018/01/04/排序4：选择排序/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;选择排序是一种简单直接的选择排序算法，每趟在未排序的数列中找到最小（或者最大）的元素，然后将其放在数列的起始（或末尾）位置。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序,选择" scheme="http://winterfu.github.io/tags/%E6%8E%92%E5%BA%8F-%E9%80%89%E6%8B%A9/"/>
    
  </entry>
  
  <entry>
    <title>排序（三）：直接插入排序</title>
    <link href="http://winterfu.github.io/2018/01/04/%E6%8E%92%E5%BA%8F3%EF%BC%9A%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/"/>
    <id>http://winterfu.github.io/2018/01/04/排序3：直接插入排序/</id>
    <published>2018-01-04T03:00:36.000Z</published>
    <updated>2018-01-04T09:06:16.052Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：直接插入排序（Straight Insertion Sort)是一种最简单的插入排序，每次将无序部分的元素放到有序部分来即可。<br><img src="/2018/01/04/排序3：直接插入排序/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;快速排序是一种简单的插入排序算法，为了简单起见，这里我们只讨论升序排序。<br><a id="more"></a></p><h3 id="二、算法思想"><a href="#二、算法思想" class="headerlink" title="二、算法思想"></a><strong>二、算法思想</strong></h3><p>&ensp;&ensp;把n个<font color="red">待排序的元素</font>看成为一个<font color="red">有序</font>表和一个<font color="red">无序</font>表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它<font color="red">插入</font>到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。</p><h4 id="1、算法图解"><a href="#1、算法图解" class="headerlink" title="1、算法图解"></a><strong>1、算法图解</strong></h4><p>&ensp;&ensp;下面选取直接插入排序的一个中间过程对其进行说明。假设{20,30,40,10,60,50}中的前3个数已经排列过，是有序的了；接下来对10进行排列。示意图如下：<br> <img src="/2018/01/04/排序3：直接插入排序/f1.jpg" alt=""><br> &ensp;&ensp;图中将数列分为有序区和无序区。我们需要做的工作只有两个：(1)取出无序区中的第1个数，并找出它在有序区对应的位置。(2)将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。看，是不是很简单。</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; 根据上面的思路，不难写出直接插入排序的实现，首先我们用C/C++实现:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;vector&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line">vector&lt;int&gt; insertsort(vector&lt;int&gt; list)&#123;</div><div class="line">vector&lt;int&gt; result;</div><div class="line"><span class="keyword">if</span>(list.empty())&#123;</div><div class="line">return result;</div><div class="line">&#125;</div><div class="line"></div><div class="line">result = list;</div><div class="line"><span class="comment">// 第一个数肯定是有序的，从第二个数开始遍历，一次插入到有序序列</span></div><div class="line">for（int i = 1; i &lt; result.size(); i++)&#123;</div><div class="line"><span class="comment">// 取出第i个数，在前i-1个数中找一个合适位置</span></div><div class="line">int temp = result[i];</div><div class="line"></div><div class="line">int j = i - 1;</div><div class="line">for(j; j &gt;= 0 &amp;&amp; result[j] &gt; temp; j--)&#123;</div><div class="line">result[j+<span class="number">1</span>] = result[j]</div><div class="line">&#125;</div><div class="line">result[j+1] = temp;</div><div class="line">&#125;</div><div class="line"></div><div class="line">return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">def insert_sort(lists):</div><div class="line">    # 插入排序</div><div class="line">    count = len(lists)</div><div class="line">    <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">1</span>, count):</div><div class="line">        key = lists[i]</div><div class="line">        j = <span class="selector-tag">i</span> - <span class="number">1</span></div><div class="line">        while j &gt;= <span class="number">0</span>:</div><div class="line">            <span class="keyword">if</span> lists[j] &gt; key:</div><div class="line">                lists[j + <span class="number">1</span>] = lists[j]</div><div class="line">                lists[j] = key</div><div class="line">            j -= <span class="number">1</span></div><div class="line">    return lists</div></pre></td></tr></table></figure><p>&ensp;&ensp;ke可以看到插入排序要做的事情就是每次从无序序列中拿一个元素，然后在有序序列中找一个合适的位置将其插入，以保证有序序列的序列次序不变，可以使用二分查找，较少元素比较次数提高效率，这可以作为算法优化的点。</p><p>&ensp;&ensp;所谓二分查找是对于有序数组而言的，假设如果数组是升序排序的。那么，二分查找算法就是不断对数组进行对半分割，每次拿中间元素和目标数字进行比较，如果中间元素小于目标数字，则说明目标数字应该在左侧被分割的数组中，如果中间元素大于目标数字，则说明目标数字应该在右侧被分割的数组中。<br>具体实现：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;vector&gt;</div><div class="line"></div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="comment">// 给定一个有序的数组，查找第一个大于等于value的下标，不存在返回-1</span></div><div class="line">int BinarySearch(vector&lt;int&gt; list, int n, int value)&#123;</div><div class="line">int <span class="attribute">left</span> = <span class="number">0</span>;</div><div class="line">int <span class="attribute">right</span> = n - <span class="number">1</span>;</div><div class="line"></div><div class="line">while (<span class="attribute">left</span> &lt;= right)&#123;</div><div class="line">int middle = <span class="attribute">left</span> + ((right - left) &gt;&gt; <span class="number">1</span>);</div><div class="line"></div><div class="line"><span class="keyword">if</span> (list[middle] &gt;= value)&#123;</div><div class="line"><span class="attribute">right</span> = middle - <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"><span class="keyword">else</span>&#123;</div><div class="line"><span class="attribute">left</span> = middle + <span class="number">1</span>;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">return (<span class="attribute">left</span> &lt; n) ? left : -<span class="number">1</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">vector&lt;int&gt; BinaryInsertSort(vector&lt;int&gt; list)&#123;</div><div class="line">vector&lt;int&gt; result = list;</div><div class="line">for (int i = 1; i &lt; result.size(); i++)&#123;</div><div class="line">int insert_index = BinarySearch(result, i, result[i]);</div><div class="line"><span class="keyword">if</span> (insert_index != -<span class="number">1</span>)&#123;</div><div class="line">int temp = result[i];</div><div class="line">int j = i - 1;</div><div class="line">while (j &gt;= insert_index)&#123;</div><div class="line">result[j + 1] = result[j];</div><div class="line">j--;</div><div class="line">&#125;</div><div class="line">result[j + 1] = temp;</div><div class="line">&#125;</div><div class="line">printf("第 %d 趟： ", i);</div><div class="line">for (int i = 0; i &lt; result.size(); i++)&#123;</div><div class="line">cout &lt;&lt; result[i] &lt;&lt; " ";</div><div class="line">&#125;</div><div class="line">cout &lt;&lt; endl;</div><div class="line">&#125;</div><div class="line">return result;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;查找插入位置的次数减少了，提高了算法效率。</p><h3 id="三、时间空间复杂度及算法稳定性分析"><a href="#三、时间空间复杂度及算法稳定性分析" class="headerlink" title="三、时间空间复杂度及算法稳定性分析"></a><strong>三、时间空间复杂度及算法稳定性分析</strong></h3><p>&ensp;&ensp;直接插入排序的时间复杂度是O(N2)：假设被排序的数列中有N个数，遍历一趟时间复杂度是O(N)，需遍历多少次呢？N-1次，因此，其时间复杂度是O(N2)。</p><p>&ensp;&ensp;由直接插入排序法可知，我们在排序的过程中，需要一个临时变量存储要插入的值，所以空间复杂度为1.<br>&ensp;&ensp;直接插入排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：直接插入排序（Straight Insertion Sort)是一种最简单的插入排序，每次将无序部分的元素放到有序部分来即可。&lt;br&gt;&lt;img src=&quot;/2018/01/04/排序3：直接插入排序/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;快速排序是一种简单的插入排序算法，为了简单起见，这里我们只讨论升序排序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序,插入" scheme="http://winterfu.github.io/tags/%E6%8E%92%E5%BA%8F-%E6%8F%92%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>排序(二）：快速排序</title>
    <link href="http://winterfu.github.io/2018/01/04/%E6%8E%92%E5%BA%8F2%EF%BC%9A%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://winterfu.github.io/2018/01/04/排序2：快速排序/</id>
    <published>2018-01-04T01:57:02.000Z</published>
    <updated>2018-01-04T03:24:59.183Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：快速排序（Quick Sort)是一种“分治策略”，每次将要排列的数组二分治之，递归调用，直至满足条件。<br><img src="/2018/01/04/排序2：快速排序/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;快速排序是一种简单的排序算法，也是一种<strong>二分排序</strong>。<br>&ensp;&ensp;所谓二分排序就是不断地将数列分成两部分然后进行递归排序。<br><a id="more"></a></p><h3 id="二、算法思想"><a href="#二、算法思想" class="headerlink" title="二、算法思想"></a><strong>二、算法思想</strong></h3><p>&ensp;&ensp;选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。</p><h4 id="1、算法图解"><a href="#1、算法图解" class="headerlink" title="1、算法图解"></a><strong>1、算法图解</strong></h4><p>&ensp;&ensp;快速排序的算法流程如下：</p><ul><li>从数列中挑出一个基准值</li><li>将所有比基准值小的摆在基准前面，所有比基准大的摆在基准的后面（相同的数可以放在任意一遍）；在这个分区退出后，该基准就处于数列的中间位置。</li><li><p>递归地把“基准值前面的子数列”和“基准值后面的子数列”进行排序</p><p>&ensp;&ensp;快速排序图文说明：下面以数列a = {30，40，60，10，20，50}为例，演示它的快速排序过程（如下图）。<br><img src="/2018/01/04/排序2：快速排序/f1.jpg" alt=""><br>&ensp;&ensp;上图只是给出了第1趟快速排序的流程。第1趟流程中，首先设置基数x=a[i]=a[0],即x=30.我们首先分析<strong>第一趟</strong>排序：</p></li><li>从”右 –&gt; 左”查找小于x的数：找到满足条件的 数 a[j]=20，此<br>时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历；</li><li>从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历；</li><li>从”右 –&gt; 左”查找小于x的数：找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。</li><li>从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。</li><li>从”右 –&gt; 左”查找小于x的数：没有找到满足条件的数。当i&gt;=j 时，停止查找；然后将x赋值给a[i]。第一趟遍历结束！</li></ul><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; 根据上面的思路，不难写出快速排序的实现，首先我们用C/C++实现:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/*</span></div><div class="line"><span class="comment">* 快速排序</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">* 参数说明：</span></div><div class="line"><span class="comment">* a -- 待排序的数组</span></div><div class="line"><span class="comment">* l -- 数组的左边界(例如，从起始位置开始排序，则l=0)</span></div><div class="line"><span class="comment">* r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)</span></div><div class="line"><span class="comment">*</span></div><div class="line"><span class="comment">*/</span></div><div class="line">void quick_sort(int <span class="selector-tag">a</span>[], int l, int r)</div><div class="line">&#123;</div><div class="line">    <span class="keyword">if</span> (l &lt; r)</div><div class="line">    &#123;</div><div class="line">        int i,j,x;</div><div class="line"></div><div class="line">        i = l;</div><div class="line">        j = r;</div><div class="line">       x = a[i];</div><div class="line">        while (<span class="selector-tag">i</span> &lt; j)</div><div class="line">        &#123;</div><div class="line">            while(<span class="selector-tag">i</span> &lt; j &amp;&amp; <span class="selector-tag">a</span>[j] &gt; x)</div><div class="line">                j--; // 从右向左找第一个小于x的数</div><div class="line">         <span class="keyword">if</span>(<span class="selector-tag">i</span> &lt; j)</div><div class="line">            a[i++] = a[j];</div><div class="line">            while(<span class="selector-tag">i</span> &lt; j &amp;&amp; <span class="selector-tag">a</span>[i] &lt; x)</div><div class="line">                i++; // 从左向右找第一个大于x的数</div><div class="line">        <span class="keyword">if</span>(<span class="selector-tag">i</span> &lt; j)</div><div class="line">            a[j--] = a[i];</div><div class="line">        &#125;</div><div class="line">        a[i] = x;</div><div class="line">        quick_sort(a, l, i-1); /* 递归调用 */</div><div class="line">        quick_sort(a, i+1, r); /* 递归调用 */</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line">def quick_sort(lists, left, right):</div><div class="line">    # 快速排序</div><div class="line">    <span class="keyword">if</span> <span class="attribute">left</span> &gt;= right:</div><div class="line">        return lists</div><div class="line">    key = lists[<span class="attribute">left</span>]</div><div class="line">    low = <span class="attribute">left</span></div><div class="line">    high = <span class="attribute">right</span></div><div class="line">    while <span class="attribute">left</span> &lt; right:</div><div class="line">        while <span class="attribute">left</span> &lt; right and lists[right] &gt;= key:</div><div class="line">            <span class="attribute">right</span> -= <span class="number">1</span></div><div class="line">        lists[<span class="attribute">left</span>] = lists[right]</div><div class="line">        while <span class="attribute">left</span> &lt; right and lists[left] &lt;= key:</div><div class="line">            <span class="attribute">left</span> += <span class="number">1</span></div><div class="line">        lists[<span class="attribute">right</span>] = lists[left]</div><div class="line">    lists[<span class="attribute">right</span>] = key</div><div class="line">    quick_sort(lists, low, <span class="attribute">left</span> - <span class="number">1</span>)</div><div class="line">    quick_sort(lists, <span class="attribute">left</span> + <span class="number">1</span>, high)</div><div class="line">    return lists</div><div class="line"></div><div class="line"></div><div class="line">def quicksort(arr):</div><div class="line">    <span class="keyword">if</span> len(arr) &lt;= <span class="number">1</span>:</div><div class="line">        return arr</div><div class="line">        </div><div class="line">    pivot = arr[len(arr) / <span class="number">2</span>]</div><div class="line"></div><div class="line">    <span class="attribute">left</span> = [x for x in arr if x &lt; pivot]</div><div class="line">   middle = [x <span class="keyword">for</span> x <span class="keyword">in</span> arr <span class="keyword">if</span> x == pivot]</div><div class="line">    <span class="attribute">right</span> = [x for x in arr if x &gt; pivot]</div><div class="line"></div><div class="line">    return quicksort(<span class="attribute">left</span>) + middle + quciksort(right)</div></pre></td></tr></table></figure><h3 id="三、时间复杂度及算法稳定性分析"><a href="#三、时间复杂度及算法稳定性分析" class="headerlink" title="三、时间复杂度及算法稳定性分析"></a><strong>三、时间复杂度及算法稳定性分析</strong></h3><p>&ensp;&ensp;快速排序的时间复杂度：快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。</p><p>&ensp;&ensp;为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。</p><p>&ensp;&ensp;为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。</p><p>&ensp;&ensp;快速排序的稳定性：快速排序是不稳定的算法，它不满足稳定算法的定义；所谓算法稳定性指的是对于一个数列中的两个相等的数a[i]=a[j]，在排序前,a[i]在a[j]前面，经过排序后a[i]仍然在a[j]前，那么这个排序算法是稳定的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：快速排序（Quick Sort)是一种“分治策略”，每次将要排列的数组二分治之，递归调用，直至满足条件。&lt;br&gt;&lt;img src=&quot;/2018/01/04/排序2：快速排序/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;快速排序是一种简单的排序算法，也是一种&lt;strong&gt;二分排序&lt;/strong&gt;。&lt;br&gt;&amp;ensp;&amp;ensp;所谓二分排序就是不断地将数列分成两部分然后进行递归排序。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序,快排" scheme="http://winterfu.github.io/tags/%E6%8E%92%E5%BA%8F-%E5%BF%AB%E6%8E%92/"/>
    
  </entry>
  
  <entry>
    <title>排序(一)：冒泡排序</title>
    <link href="http://winterfu.github.io/2018/01/04/%E6%8E%92%E5%BA%8F1%EF%BC%9A%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/"/>
    <id>http://winterfu.github.io/2018/01/04/排序1：冒泡排序/</id>
    <published>2018-01-04T01:15:47.000Z</published>
    <updated>2018-01-04T07:51:07.030Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：冒泡排序是一种交换排序。什么是交换排序呢？答曰：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。<br><img src="/2018/01/04/排序1：冒泡排序/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;冒泡排序是一种简单的排序算法，也是一种<strong>交换排序</strong>。<br>&ensp;&ensp;所谓交换排序就是不断地进行两两比较，满足条件则交换，不满足不交换。<br><a id="more"></a></p><h3 id="二、算法思想"><a href="#二、算法思想" class="headerlink" title="二、算法思想"></a><strong>二、算法思想</strong></h3><p>&ensp;&ensp;它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！</p><h4 id="1、算法图解"><a href="#1、算法图解" class="headerlink" title="1、算法图解"></a><strong>1、算法图解</strong></h4><p>&ensp;&ensp;下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)。<br><img src="/2018/01/04/排序1：冒泡排序/f1.png" alt=""><br>&ensp;&ensp;我们首先分析<strong>第一趟</strong>排序：<br><img src="/2018/01/04/排序1：冒泡排序/f2.png" alt=""></p><p>第一趟排完之后，最大元素60移到数组最后了，也就是a[5]此时为数组中最大的元素，再进行第二趟排序的时候，只需按照上面的方法排前面5个元素就可以了。这样：<br>第2趟排序完之后，数列中a[4]、a[5]是有序的。<br>第3趟排序完之后，数列中a[3]、a[4]、a[5]是有序的。<br>第4趟排序完之后，数列中a[2]、[3]、a[4]、a[5]是有序的。<br>第5趟排序完之后，数列中a[1]、a[2]、[3]、a[4]、a[5]是有序的。<br>第5趟排序之后，整个数列也就是有序的了。</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; 根据上面的流程，不难写出冒泡排序的实现，首先我们用C/C++实现，此处是按<strong>升序</strong>排序:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">void bubble_sort(int <span class="selector-tag">a</span>[], int n)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line"></div><div class="line">    for (i=n-1; i&gt;0; i--)</div><div class="line">    &#123;</div><div class="line">        <span class="comment">// 将a[0...i]中最大的数据放在末尾</span></div><div class="line">        for (j=0; j&lt;i; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="selector-tag">a</span>[j] &gt; <span class="selector-tag">a</span>[j+<span class="number">1</span>])</div><div class="line">            swap(a[j], a[j+1]);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">void swap(int x, int y)</div><div class="line">&#123;</div><div class="line">int temp;</div><div class="line">temp = x;</div><div class="line">x = y;</div><div class="line">y = temp;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp; 其实观察上面例子冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。因此可以对冒泡排序进行<strong>优化</strong>，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成，退出。<strong>优化后</strong>的代码如下：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">void bubble_sort2(int <span class="selector-tag">a</span>[], int n)</div><div class="line">&#123;</div><div class="line">    int i,j;</div><div class="line">    int flag;     // 标记一趟是否发生交换</div><div class="line">    for (i=n-1; i&gt;0; i--)</div><div class="line">    &#123;</div><div class="line">        flag = 0;     // 初始化标记为0</div><div class="line">        <span class="comment">// 将a[0...i]中最大的数据放在末尾</span></div><div class="line">        for (j=0; j&lt;i; j++)</div><div class="line">        &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="selector-tag">a</span>[j] &gt; <span class="selector-tag">a</span>[j+<span class="number">1</span>])</div><div class="line">            &#123;</div><div class="line">                swap(a[j], a[j+1]);</div><div class="line">                flag = 1; //发生交换，设flag为1</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (flag==<span class="number">0</span>)</div><div class="line">            break; // 若无交换，说明数列已有序</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line"> </div><div class="line">def bubbleSort(input_list):</div><div class="line"><span class="keyword">if</span> len(input_list)</div><div class="line">def bubble_sort(lists):</div><div class="line"># 冒泡排序</div><div class="line"><span class="keyword">if</span> len(lists) == <span class="number">0</span>:</div><div class="line">return []</div><div class="line">count = len(lists)</div><div class="line"></div><div class="line"><span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(count):</div><div class="line"><span class="keyword">for</span> j <span class="keyword">in</span> range(<span class="selector-tag">i</span> + <span class="number">1</span>, count):</div><div class="line"><span class="keyword">if</span> lists[i] &gt; lists[j]:</div><div class="line">lists[i], lists[j] = lists[j], lists[i]</div><div class="line"></div><div class="line">return lists</div></pre></td></tr></table></figure><h3 id="三、时间复杂度及算法稳定性分析"><a href="#三、时间复杂度及算法稳定性分析" class="headerlink" title="三、时间复杂度及算法稳定性分析"></a><strong>三、时间复杂度及算法稳定性分析</strong></h3><p>&ensp;&ensp;冒泡排序的时间复杂度是O(N2)：假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度O(N2)。</p><p>&ensp;&ensp;冒泡排序是稳定的算法：它满足稳定算法的定义；所谓算法稳定性指的是对于一个数列中的两个相等的数a[i]=a[j]，在排序前,a[i]在a[j]前面，经过排序后a[i]仍然在a[j]前，那么这个排序算法是稳定的。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：冒泡排序是一种交换排序。什么是交换排序呢？答曰：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。&lt;br&gt;&lt;img src=&quot;/2018/01/04/排序1：冒泡排序/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;冒泡排序是一种简单的排序算法，也是一种&lt;strong&gt;交换排序&lt;/strong&gt;。&lt;br&gt;&amp;ensp;&amp;ensp;所谓交换排序就是不断地进行两两比较，满足条件则交换，不满足不交换。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="排序,冒泡" scheme="http://winterfu.github.io/tags/%E6%8E%92%E5%BA%8F-%E5%86%92%E6%B3%A1/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(七)：斐波那契数列</title>
    <link href="http://winterfu.github.io/2017/12/26/%E5%89%91%E6%8C%87Offer-7%EF%BC%9A%E8%8F%B2%E6%B3%A2%E9%82%A3%E5%88%87%E6%95%B0%E5%88%97/"/>
    <id>http://winterfu.github.io/2017/12/26/剑指Offer-7：菲波那切数列/</id>
    <published>2017-12-26T13:36:12.000Z</published>
    <updated>2018-01-10T08:05:28.280Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br><img src="/2017/12/26/剑指Offer-7：菲波那切数列/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;斐波那切数列，相信大家都不陌生吧，对就是那个我们小时候常做的问题，什么小兔子生兔子的问题，还有一些花的花瓣数也是符合斐波那契数列的规律的，因此也称其为“迷人的斐波那契数列”，在数学上，斐波那契数列以递归的方式定义：F(0) = 0，F(1) = 1， F(n) = F(n-1) + F(n-2) (n&gt;=2，n为正整数)</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:<br>1.首先我们就可以按照其定义方式，用递归的思想来实现：</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n&lt;=0) return 0;</div><div class="line"> if(n==1 || n==2) return 1;</div><div class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>这里存在一个问题就是，当n比较大的时候会出现溢出的情况。</p><p>2.动态规划的思想</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        int f = 0, g = 1;</div><div class="line">        while(n--) &#123;</div><div class="line">            g += f;</div><div class="line">            f = g - f;</div><div class="line">        &#125;</div><div class="line">        return f;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>3.全面考虑，把负数，大数，算法的复杂度，空间浪费都考虑进来</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int Fibonacci(int n) &#123;</div><div class="line">        <span class="comment">//方法1：用递归，系统会让一个超大的n来让Stack Overflow，所以</span></div><div class="line">        <span class="comment">//递归就不考虑了</span></div><div class="line">         </div><div class="line">        <span class="comment">//使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来</span></div><div class="line">        int fn1 = 1;</div><div class="line">        int fn2 = 1;</div><div class="line">         </div><div class="line">        <span class="comment">//考虑出错情况</span></div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//第一和第二个数直接返回</span></div><div class="line">        if (n == 1 || n == 2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">//当n&gt;=3时，走这里，用迭代法算出结果</span></div><div class="line">        <span class="comment">//这里也说明了，要用三个数操作的情况，其实也可以简化为两</span></div><div class="line">        <span class="comment">//个数，从而节省内存空间</span></div><div class="line">        while (n-- &gt; <span class="number">2</span>) &#123;</div><div class="line">            fn1 += fn2;</div><div class="line">            fn2 = fn1 - fn2;</div><div class="line">        &#125;</div><div class="line">        return fn1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>4.尾递归，递归总归来说是栈，可能导致栈溢出</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int Fibonacci(int n) &#123;</div><div class="line">        return Fibonacci(n,0,1);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    private static int Fibonacci(int n,int acc1,int acc2)&#123;</div><div class="line">        if(n==0) return 0;</div><div class="line">        if(n==1) return acc2;</div><div class="line">        else     return Fibonacci(n - 1, acc2, acc1 + acc2);</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:<br>1.递归实现</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def fib(n):</div><div class="line">    return <span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">1</span> <span class="keyword">else</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)              #很简单的一个三目运算符实现</div><div class="line"></div><div class="line">def fib(n):</div><div class="line">    dic = &#123; <span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>: <span class="number">1</span>&#125;</div><div class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</div><div class="line">        return dict[n]</div><div class="line">    retrun fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</div></pre></td></tr></table></figure><p>PS：递归还有一个缺点就是需要进行很多次重复的运算</p><p>2.完美实现方案1</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def fib1(n):</div><div class="line">    stack =[]</div><div class="line">    <span class="keyword">if</span> n==<span class="number">0</span> or n==<span class="number">1</span>:</div><div class="line">       return <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        stack.append(<span class="number">1</span>)</div><div class="line">        stack.append(<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            stack.append(stack[i-<span class="number">1</span>] + stack[i-<span class="number">2</span>])</div><div class="line">        retrun stack</div></pre></td></tr></table></figure><p>3.完美实现方案2</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def fib2(number):</div><div class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    result = []</div><div class="line">    while y &lt; number:</div><div class="line">        result.append(y)</div><div class="line">        x, y = y, x+y</div><div class="line">    return result</div></pre></td></tr></table></figure><p>4.完美实现方案3，吧其编程一个生成器的形式，可以使用循环将其输出出来</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def fib3():</div><div class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    while True:</div><div class="line">        yeild x</div><div class="line">        x, y = y, x+y</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    import itertools</div><div class="line">    print(list(itertools.islice(fib(), <span class="number">10</span>))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。&lt;br&gt;&lt;img src=&quot;/2017/12/26/剑指Offer-7：菲波那切数列/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台：&lt;a href=&quot;https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;amp;tqId=11160&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="递归,循环" scheme="http://winterfu.github.io/tags/%E9%80%92%E5%BD%92-%E5%BE%AA%E7%8E%AF/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(六)：旋转数组的最小数字</title>
    <link href="http://winterfu.github.io/2017/12/25/%E5%89%91%E6%8C%87Offer-6%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/"/>
    <id>http://winterfu.github.io/2017/12/25/剑指Offer-6：旋转数组的最小数字/</id>
    <published>2017-12-25T13:44:03.000Z</published>
    <updated>2017-12-26T13:38:23.616Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br><img src="/2017/12/25/剑指Offer-6：旋转数组的最小数字/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;首先要注意有无重复数字，也就是是否严格递增。这是一道二分查找的变形题目，旋转后的之后的数字实际上可以划分为两个有序的子数组：前面的数组中的元素大小都大于后面子数组中的元素。<br>&ensp;&ensp;不难发现实际上最小的元素就是两字子数组的分界线。本题目给出的数组一定程度上是排好序的，因此我们可以采用二分法来查找。</p><ol><li>我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。但是如果不旋转，第一个元素肯定是小于最后一个元素的。</li><li>找到数组的中间元素：1&gt;中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。移动之后，第一个指针仍然位于前面的递增数组中。 2&gt;中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。移动后，第二个指针仍然位于后面的递增数组中。这样即可缩小寻找的范围。</li><li>按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</li></ol><p>&ensp;&ensp;到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。因此这一道题目比上一道题目多了些特殊情况：</p><p>&ensp;&ensp;我们看一组例子：｛1，0，<font color="red">1</font>，<font color="green">1</font>，<font color="green">1</font>｝ 和 ｛<font color="purple">1</font>，<font color="purple">1</font>， <font color="red">1</font>，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。</p><p>&ensp;&ensp;这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p><p>&ensp;&ensp;因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（<font color="green">绿色表示</font>）还是属于后面的子数组（<font color="purple">紫色表示</font>）。也就无法移动指针来缩小查找范围了。</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;vector&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;string&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;stack&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        int size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int <span class="attribute">left</span> = <span class="number">0</span>,right = size - <span class="number">1</span>;</div><div class="line">        int mid = 0;</div><div class="line">        while(rotateArray[<span class="attribute">left</span>] &gt;= rotateArray[right])&#123;</div><div class="line">            <span class="comment">// 分界点</span></div><div class="line">            <span class="keyword">if</span>(<span class="attribute">right</span> - left == <span class="number">1</span>)&#123;</div><div class="line">                mid = <span class="attribute">right</span>;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            mid = <span class="attribute">left</span> + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="comment">// rotateArray[left] rotateArray[right] rotateArray[mid]三者相等</span></div><div class="line">            <span class="comment">// 无法确定中间元素是属于前面还是后面的递增子数组</span></div><div class="line">            <span class="comment">// 只能顺序查找</span></div><div class="line">            <span class="keyword">if</span>(rotateArray[<span class="attribute">left</span>] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])&#123;</div><div class="line">                return MinOrder(rotateArray,<span class="attribute">left</span>,right);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 中间元素位于前面的递增子数组</span></div><div class="line">            <span class="comment">// 此时最小元素位于中间元素的后面</span></div><div class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[<span class="attribute">left</span>])&#123;</div><div class="line">                <span class="attribute">left</span> = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 中间元素位于后面的递增子数组</span></div><div class="line">            <span class="comment">// 此时最小元素位于中间元素的前面</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="attribute">right</span> = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[mid];</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    <span class="comment">// 顺序寻找最小值</span></div><div class="line">    int MinOrder(vector&lt;int&gt; &amp;num,int <span class="attribute">left</span>,int right)&#123;</div><div class="line">        int result = num[<span class="attribute">left</span>];</div><div class="line">        <span class="keyword">for</span>(int <span class="selector-tag">i</span> = <span class="attribute">left</span> + <span class="number">1</span>;<span class="selector-tag">i</span> &lt; <span class="attribute">right</span>;++i)&#123;</div><div class="line">            <span class="keyword">if</span>(num[i] &lt; result)&#123;</div><div class="line">                result = num[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main()&#123;</div><div class="line">    Solution s;</div><div class="line">    <span class="comment">//vector&lt;int&gt; num = &#123;0,1,2,3,4,5&#125;;</span></div><div class="line">    <span class="comment">//vector&lt;int&gt; num = &#123;4,5,6,7,1,2,3&#125;;</span></div><div class="line">    vector&lt;int&gt; num = &#123;2,2,2,2,1,2&#125;;</div><div class="line">    int result = s.minNumberInRotateArray(num);</div><div class="line">    <span class="comment">// 输出</span></div><div class="line">    cout&lt;&lt;result&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">&#125;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">def find_rotation_array_min(roation_array):</div><div class="line">    n = len(roation_array)</div><div class="line">    <span class="keyword">if</span> roation_array[<span class="number">0</span>] &lt; roation_array[-<span class="number">1</span>]:</div><div class="line">        return <span class="number">0</span></div><div class="line">    <span class="attribute">left</span> = <span class="number">0</span></div><div class="line">    <span class="attribute">right</span> = n-<span class="number">1</span></div><div class="line">    while roation_array[<span class="attribute">left</span>] &gt;= roation_array[right]:</div><div class="line">        <span class="keyword">if</span> <span class="attribute">right</span>-left == <span class="number">1</span>:</div><div class="line">            mid = <span class="attribute">right</span></div><div class="line">            break</div><div class="line">        mid = <span class="attribute">left</span> + int((right - left) / <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span>(roation_array[<span class="attribute">left</span>]==roation_array[right] and roation_array[left] == roation_array[mid]):</div><div class="line">            return min(roation_array)</div><div class="line">        <span class="keyword">if</span>(roation_array[mid] &gt;= roation_array[<span class="attribute">left</span>]):</div><div class="line">            <span class="attribute">left</span> =mid</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="attribute">right</span>=mid</div><div class="line">    return roation_array[mid]</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    s = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">    <span class="selector-tag">q</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">    print(find_rotation_array_min(s), find_rotation_array_min(q))</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。&lt;br&gt;&lt;img src=&quot;/2017/12/25/剑指Offer-6：旋转数组的最小数字/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台：&lt;a href=&quot;https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;amp;tqId=11159&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数组,查找,排序" scheme="http://winterfu.github.io/tags/%E6%95%B0%E7%BB%84-%E6%9F%A5%E6%89%BE-%E6%8E%92%E5%BA%8F/"/>
    
  </entry>
  
  <entry>
    <title>浅谈神经网络中激励函数的作用</title>
    <link href="http://winterfu.github.io/2017/12/25/%E6%B5%85%E8%B0%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%BF%80%E5%8A%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/"/>
    <id>http://winterfu.github.io/2017/12/25/浅谈神经网络中激励函数的作用/</id>
    <published>2017-12-25T11:30:25.000Z</published>
    <updated>2017-12-25T13:11:35.278Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/12/25/浅谈神经网络中激励函数的作用/ff.jpg" alt=""></p><h3 id="什么是激活函数？"><a href="#什么是激活函数？" class="headerlink" title="什么是激活函数？"></a><strong>什么是激活函数？</strong></h3><p>&ensp;&ensp;我想z这一点也不用多说，无论是搞机器学习还是深度学习的对于激活函数这个名词已经再熟悉不过了，因为搭建网络的时候都会要用到它，虽然我们无时无刻都在使用它，但是我们真的知其然也知其所以然么？</p><ul><li>首先问自己一个问题，在解决复杂问题用的神经网络模型中如果没有激活函数可以么？</li><li>很显然，不可以！！！</li></ul><p>&ensp;&ensp;那么肯定又会有人问了为什么不可以，那有无激活函数又有什么区别，激活函数的作用又是什么呢？</p><a id="more"></a><p>&ensp;&ensp;且听我慢慢道来：<br>&ensp;&ensp;首先回答，为什么不可以，神经网络之所以很强大，能够解决很多复杂问题，很重要的一点就是其引入了非线性，那么是通过什么引入的呢？没错就是你想的那样，通过激活函数，这样它才能够解决一些复杂的非线性问题，如果没有激活函数，或者是线性激活函数，那么就跟普通的线性方程别无二致了，这肯定不是我们想要的。</p><h3 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a><strong>激活函数的作用</strong></h3><ul><li>激活函数是用来加入非线性因素的，解决线性模型所不能解决的问题</li><li>激活函数可以用来组合训练数据的特征，使特征充分组合</li></ul><p>&ensp;&ensp;在这里第一个特点上面我们也提到了，主要是用来引入非线性，提高神经网络的表达能力，更好的解决复杂的非线性问题。单层感知机解决不了异或问题，多层感知机可以解决异或但是再加入一点非线性其能力还是很弱，这已经是个老生常谈的话题了。</p><p>&ensp;&ensp;下面主要从第二个特点我们进行说明一下：</p><p>&ensp;&ensp;首先我们看一个简单的感知机的例子：<br><img src="/2017/12/25/浅谈神经网络中激励函数的作用/dd.png" alt=""></p><p>&ensp;&ensp;其中，x1和x2为特征输入，x3 = w1 <em> x1 + w2 </em> x2，激活函数采用sigmoid函数，公式表达式如下：<br><img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large g(x)=\frac{1}{1+e^{-x}}" style="border:none;"></p><p>则<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large g(x3)=\frac{1} {1 + e^{-x3}}" style="border:none;"></p><p>&ensp;&ensp;此时，我们可能看不出什么不同，下面我们进行泰勒展开，</p><p><img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large e^x=1 + \frac{1} {1!}x + \frac{1} {2!} x^2 + \frac{1} {3!} x^3 + o(x^3)" style="border:none;"></p><p>&ensp;&ensp;通过泰勒展开。我们不难看到，我们已经构造出立方激活函数的形式了，我们能够看到，将x3带入到激活函数中时，将激活函数中的指数项按照泰勒级数展开后，就会有平方项，立方项，有更高的项，这些能够把输入特征进行亮亮组合，进行三三组合或者其他组合。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>&ensp;&ensp;激活函数在神经网络模型的构建中必不可少，能够引入一定的非线性因素，增强网络的表达能力；此外还可以把原来需要领域知识的专家对特征进行组合的情况，在激活函数运算后，其实也能够起到特征组合的作用。（只要激活函数中能有用泰勒级数展开的函数，就可以对特征起到组合的作用）</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/12/25/浅谈神经网络中激励函数的作用/ff.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;什么是激活函数？&quot;&gt;&lt;a href=&quot;#什么是激活函数？&quot; class=&quot;headerlink&quot; title=&quot;什么是激活函数？&quot;&gt;&lt;/a&gt;&lt;strong&gt;什么是激活函数？&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;我想z这一点也不用多说，无论是搞机器学习还是深度学习的对于激活函数这个名词已经再熟悉不过了，因为搭建网络的时候都会要用到它，虽然我们无时无刻都在使用它，但是我们真的知其然也知其所以然么？&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;首先问自己一个问题，在解决复杂问题用的神经网络模型中如果没有激活函数可以么？&lt;/li&gt;
&lt;li&gt;很显然，不可以！！！&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;那么肯定又会有人问了为什么不可以，那有无激活函数又有什么区别，激活函数的作用又是什么呢？&lt;/p&gt;
    
    </summary>
    
      <category term="机器学习" scheme="http://winterfu.github.io/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="激活函数,sigmoid" scheme="http://winterfu.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0-sigmoid/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(五)：栈和队列</title>
    <link href="http://winterfu.github.io/2017/12/21/%E5%89%91%E6%8C%87Offer-5%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/"/>
    <id>http://winterfu.github.io/2017/12/21/剑指Offer-5：栈和队列/</id>
    <published>2017-12-21T14:09:03.000Z</published>
    <updated>2017-12-21T14:26:45.285Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><img src="/2017/12/21/剑指Offer-5：栈和队列/ppo.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题目首先要知道队列和栈各自的特点，那么接下来就按照这种特点去设计即可：</p><ul><li>入队：将元素进栈A</li><li>出队：判断栈B是否为空，如果为空，则将栈A中所有的元素pop，并push进栈B，栈B出栈；如果不为空则栈B直接出栈。</li></ul><p>&ensp;&ensp;这里同样可以用两个队列实现一个栈的功能：</p><ul><li>入栈：将元素进队列A</li><li>出栈：判断队列A中元素个数是否为1，如果等于1则出队列，否则将队列A中的元素，一次出队列并放入队列B中，直到队列A中的元素留下最后一个，然后队列A出队列，再把队列B中的元素出队列一次放入队列A中。</li></ul><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    int pop() &#123;</div><div class="line">        int temp;</div><div class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</div><div class="line">            while(!stack1.empty())&#123;</div><div class="line">                temp = stack1.<span class="attribute">top</span>();</div><div class="line">                stack2.push(temp);</div><div class="line">                stack1.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = stack2.<span class="attribute">top</span>();</div><div class="line">        stack2.pop();</div><div class="line">        return temp;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure><p>&ensp;&ensp;人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self<span class="selector-class">.stackA</span> = [ ]</div><div class="line">        self<span class="selector-class">.stackB</span> = [ ]</div><div class="line">         </div><div class="line">    def push(self, node):</div><div class="line">        # write code here</div><div class="line">        self<span class="selector-class">.stackA</span><span class="selector-class">.append</span>(node)</div><div class="line">         </div><div class="line">    def pop(self):</div><div class="line">        # return xx</div><div class="line">        <span class="keyword">if</span> self<span class="selector-class">.stackB</span>:</div><div class="line">            return self<span class="selector-class">.stackB</span><span class="selector-class">.pop</span>()</div><div class="line">        elif not self<span class="selector-class">.stackA</span>:</div><div class="line">            return None</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            while self<span class="selector-class">.stackA</span>:</div><div class="line">                self<span class="selector-class">.stackB</span><span class="selector-class">.append</span>(self<span class="selector-class">.stackA</span><span class="selector-class">.pop</span>())</div><div class="line">            return self<span class="selector-class">.stackB</span><span class="selector-class">.pop</span>()</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。&lt;br&gt;&lt;img src=&quot;/2017/12/21/剑指Offer-5：栈和队列/ppo.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台：&lt;a href=&quot;https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;amp;tqId=11158&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="队列,栈" scheme="http://winterfu.github.io/tags/%E9%98%9F%E5%88%97-%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>全球AI挑战赛之场景分类赛后总结篇</title>
    <link href="http://winterfu.github.io/2017/12/21/%E5%85%A8%E7%90%83AI%E6%8C%91%E6%88%98%E8%B5%9B%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E7%B1%BB%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%E7%AF%87/"/>
    <id>http://winterfu.github.io/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/</id>
    <published>2017-12-21T11:28:37.000Z</published>
    <updated>2017-12-21T13:45:56.582Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/ai.png" alt=""><br>&ensp;&ensp;全球AI挑战赛已经落下帷幕近半个月的时间了，虽然没拿到太好的名次，但是这次的实战确实是学到了不少东西，也填了不少的坑，也算是为以后的学习道路除去了很多绊脚石吧，这次和puke同学一起摸爬滚打了好些昼夜，最终坚持到了最后，下面就分享一下我们在这次比赛中的经历以及一些对于遇到的那些问题的解决方案，小的tricks吧。<br><a id="more"></a></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;首先简单说一下这个比赛，<a href="https://challenger.ai/" target="_blank" rel="external">全球AI挑战赛</a>我门选择的是场景分类这个题目，主要的任务就是将所给图片进行80场景分类，之前的ImageNet也是做过类似的比赛数据集是places-365或者200之类的，这次的数据集规模相对ImageNet的规模要小，但是图片质量还是有的保障的，我们也是大致看了一下比赛数据集中的图片，训练集5W+张，验证集7000+张，测试集分为AB榜进行测试，规模和验证集差不多，图片二义性很强，而且存在严重的不均衡现象，有些图片真的是人都很难去区分，但是机器做的很不错，不得不又得吹嘘一把DeepLearning的强大啊，哈哈哈！</p><h3 id="二、快速接入"><a href="#二、快速接入" class="headerlink" title="二、快速接入"></a><strong>二、快速接入</strong></h3><p>&ensp;&ensp;<a href="https://challenger.ai/competition/scene/subject" target="_blank" rel="external">下载数据集</a><br>&ensp;&ensp;<a href="https://github.com/puke3615/SceneClassify" target="_blank" rel="external">代码链接</a></p><h3 id="三、项目要点概述"><a href="#三、项目要点概述" class="headerlink" title="三、项目要点概述"></a><strong>三、项目要点概述</strong></h3><ul><li>支持多个单模型进行集成，可选多种集成方式</li><li>支持多种集成方式间的任意组合和自动择优</li><li>支持间断训练后在训练时权重文件的择优选择</li><li>支持VGG16、VGG19、Resnet50、Inception-V3、Xception、Inception-Resnet-V2等模型</li><li>imgaug图片数据增强库替换Keras自带的图片预处理</li></ul><h3 id="四、血泪史"><a href="#四、血泪史" class="headerlink" title="四、血泪史"></a><strong>四、血泪史</strong></h3><p> &ensp;&ensp;<strong>选好框架很重要！！！</strong></p><p>&ensp;&ensp;Tensorflow现在最流行的框架应该没有之一了吧，然而就是个大坑没毛病。其实这是谷歌开发的给工程师用的，对于小白或者教学来说还是用起来比较费劲，那为何还这么流行呢，毕竟是大厂，都懂得。虽然之后的Tensorflow出现了TFlearn和slim等高级库，但是还是写起来比较繁琐，所以像我这么懒的人呢还是果断抛弃了他，投向了Keras的怀抱，当然还有一些什么Caffee、Pytorch、MXnet啥的，至于为什么选了Keras我自己也讲不出来，Keras写起来很简单，也有一些已经预训练好的模型，但是同样在训练时有很多坑，不过现在已经被填平好多了，下面就来说一说这些坑（欢迎其他同学指正，补充！）</p><p> &ensp;&ensp;<strong>数据增强很重要！！！</strong></p><p>&ensp;&ensp;Keras自带的图片增强远远不够的，这里选择了imgaug这个图片数据增强库，直接上图，这种效果是目前的Keras望尘莫及的，尽可能最大限度利用当前有限的数据集。提高1~3个百分点<br><img src="/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/imgaug.png" alt=""></p><p>&ensp;&ensp;<strong>尽可能的去并行处理！！！</strong></p><p>&ensp;&ensp;训练任务交给GPU去做，新添加的imgaug图片处理方式之后，一个Epoch在1050Ti上耗时90mins+，排查发现大部分时间都在进行图片数据增强处理，于是将该部分的处理替换为多进程方式。<strong>时间从90mins降到30mins左右</strong></p><p>&ensp;&ensp;<strong>数据标准化很重要！！！</strong><br>&ensp;&ensp;Keras是自带的标准化都不是最合理的，首先我们要计算出整体训练集三个通道各自的mean和std而不是单个数据，更不是单个batch的。然后在训练阶段的输入数据以mean和std进行高斯处理（注意验证集也要做一样的操作，这里是为了保证同分布），<strong>提高0.5~1.0个百分点</strong>。</p><p>&ensp;&ensp;<strong>Fine-tuning时别绑太紧！！！</strong></p><p>&ensp;&ensp;这点尤为重要！Fine-tune时松太开，可能导致训练耗时，也可能导致机器带不动；绑太紧可能导致Fixed的权重参数扼制了模型的学习能力。建议是在机器能扛得住的基础下，尽可能松绑多一些，<strong>提高2~5个百分点</strong>。</p><p>&ensp;&ensp;<strong>模型选择很重要！！！</strong></p><p>&ensp;&ensp;糟糕的模型训练几天几夜，可能赶不上优势模型训练几个epoch。VGG16=&gt;Xception<strong>提高5~8个百分点</strong>。</p><p>&ensp;&ensp;<strong>Loss降不下去时尝试调低LR！！！</strong></p><p>&ensp;&ensp;降不下去就调小，调下的幅度一般是5倍、10倍左右，<strong>提高1~3个百分点</strong>。</p><p>&ensp;&ensp;<strong>TensorBoard监视训练状态！！！</strong></p><p>&ensp;&ensp;尽可能使用Tensorflow提供的Tensorboard可视化工具，方便从宏观把控训练过程。</p><p>&ensp;&ensp;<strong>适度过拟合是良性的！！！</strong></p><p>&ensp;&ensp;训练过程中一直没有过拟合，要从两方面考虑：</p><ul><li>模型太简单，拟合能力不够，这时候要考虑提高网络复杂度</li><li>数据增强程度太大，导致某些特征学不到。</li></ul><p>&ensp;&ensp;<strong>模型集成很重要！！！</strong></p><p>&ensp;&ensp;“三个臭皮匠，顶个诸葛亮”，这句话还是很有道理的，千万不要单模型一条路跑到黑，要尝试将多个模型进行集成。集成的方式可以选择投票法、均值法、按照模型Acc加权法等等，<strong>提高0.5~1.5个百分点</strong>。</p><p>&ensp;&ensp;<strong>预测数据增强！！！</strong></p><p>&ensp;&ensp;为了确保预测结果的准确性，可以将待预测结果进行水平翻转（或随机裁取patch等）处理，将这多张孪生图片进行预测，最终结果取多个结果的均值，<strong>提高0.25~1.0个百分点</strong>。</p><p>&ensp;&ensp;<strong>Teamwork is necessary!!!</strong></p><p>&ensp;&ensp;想法x2，时间/2，还能互相讨论学习！<strong>提高0~50个百分点</strong>！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/ai.png&quot; alt=&quot;&quot;&gt;&lt;br&gt;&amp;ensp;&amp;ensp;全球AI挑战赛已经落下帷幕近半个月的时间了，虽然没拿到太好的名次，但是这次的实战确实是学到了不少东西，也填了不少的坑，也算是为以后的学习道路除去了很多绊脚石吧，这次和puke同学一起摸爬滚打了好些昼夜，最终坚持到了最后，下面就分享一下我们在这次比赛中的经历以及一些对于遇到的那些问题的解决方案，小的tricks吧。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="Events" scheme="http://winterfu.github.io/categories/Events/"/>
    
    
      <category term="AI,场景识别,Keras" scheme="http://winterfu.github.io/tags/AI-%E5%9C%BA%E6%99%AF%E8%AF%86%E5%88%AB-Keras/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(四)：树</title>
    <link href="http://winterfu.github.io/2017/12/18/%E5%89%91%E6%8C%87Offer-4%EF%BC%9A%E6%A0%91/"/>
    <id>http://winterfu.github.io/2017/12/18/剑指Offer-4：树/</id>
    <published>2017-12-18T09:13:46.000Z</published>
    <updated>2017-12-18T09:26:59.204Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。<br><img src="/2017/12/18/剑指Offer-4：树/forest.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题首先要明白二叉树的遍历方法，主要分为前序、中序和后序三种遍历方法以及三种遍历的特点，那么就不难解决这个问题了，下面我们来讲一下思路。<br>&ensp;&ensp;先序遍历第一个位置肯定是根节点node，  中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组；<br>&ensp;&ensp;另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组，把四个数组找出来，分左右递归调用即可。</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**     * Definition for binary tree     </span></div><div class="line"><span class="comment">* struct TreeNode &#123;     </span></div><div class="line"><span class="comment">*     int val;    </span></div><div class="line"><span class="comment">*     TreeNode *left;     </span></div><div class="line"><span class="comment">*     TreeNode *right;     </span></div><div class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;     </span></div><div class="line"><span class="comment">* &#125;;    </span></div><div class="line"><span class="comment">*/</span>    </div><div class="line">class Solution &#123;    </div><div class="line">public:</div><div class="line">        struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123;            </div><div class="line">            int inlen=in.size();            </div><div class="line">            <span class="keyword">if</span>(inlen==<span class="number">0</span>)                </div><div class="line">                return NULL;            </div><div class="line">            vector&lt;int&gt; left_pre,right_pre,left_in,right_in;           </div><div class="line">             <span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></div><div class="line">            TreeNode* head=new TreeNode(pre[0]);            </div><div class="line">            <span class="comment">//找到中序遍历根节点所在位置,存放于变量gen中  </span></div><div class="line">            int gen=0;</div><div class="line">            for(int i=0;i&lt;inlen;i++)           </div><div class="line">     &#123;               </div><div class="line">                 <span class="keyword">if</span> (<span class="keyword">in</span>[i]==pre[<span class="number">0</span>])                </div><div class="line">                &#123;                    </div><div class="line">                    gen=i;                    </div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边            </span></div><div class="line">            <span class="comment">//利用上述这点，对二叉树节点进行归并  </span></div><div class="line">            for(int i=0;i&lt;gen;i++)            </div><div class="line">            &#123;</div><div class="line">                left_in.push_back(in[i]);                </div><div class="line">                left_pre.push_back(pre[i+1]);//前序第一个为根节点</div><div class="line">            &#125;</div><div class="line">            for(int i=gen+1;i&lt;inlen;i++)            </div><div class="line">            &#123;                </div><div class="line">                right_in.push_back(in[i]);                </div><div class="line">                right_pre.push_back(pre[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树</span></div><div class="line">            <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></div><div class="line">           head-&gt;<span class="attribute">left</span>=reConstructBinaryTree(left_pre,left_in);</div><div class="line">           head-&gt;<span class="attribute">right</span>=reConstructBinaryTree(right_pre,right_in);</div><div class="line">           return head;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure><p>&ensp;&ensp; 人生苦短，我用Python:</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class TreeNode:</div><div class="line">def __init__(self, x):</div><div class="line">        self<span class="selector-class">.val</span> = x</div><div class="line">        self<span class="selector-class">.left</span> = None</div><div class="line">self<span class="selector-class">.right</span> = None</div><div class="line"></div><div class="line">class Solution:</div><div class="line">    # 返回构造的TreeNode根节点</div><div class="line">def reConstructBinaryTree(self, pre, tin):</div><div class="line">        # write code here</div><div class="line">        <span class="keyword">if</span> len(pre) == <span class="number">0</span>:</div><div class="line">            return None</div><div class="line">        elif len(pre) == <span class="number">1</span>:</div><div class="line">            return TreeNode(pre[<span class="number">0</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            ans = TreeNode(pre[<span class="number">0</span>])</div><div class="line">            ans<span class="selector-class">.left</span> = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>], tin[:tin.index(pre[<span class="number">0</span>])])</div><div class="line">            ans<span class="selector-class">.right</span> = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:], tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:])</div><div class="line">            return ans</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。&lt;br&gt;&lt;img src=&quot;/2017/12/18/剑指Offer-4：树/forest.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台：&lt;a href=&quot;https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;amp;tqId=11157&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="树,重建" scheme="http://winterfu.github.io/tags/%E6%A0%91-%E9%87%8D%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(三)：链表</title>
    <link href="http://winterfu.github.io/2017/12/18/%E5%89%91%E6%8C%87Offer-3%EF%BC%9A%E9%93%BE%E8%A1%A8/"/>
    <id>http://winterfu.github.io/2017/12/18/剑指Offer-3：链表/</id>
    <published>2017-12-18T08:57:14.000Z</published>
    <updated>2017-12-18T09:12:18.703Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：输入一个链表，从尾到头打印链表每个节点的值。<br><img src="/2017/12/18/剑指Offer-3：链表/fg.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 输入一个链表，从尾到头打印链表每个节点的值。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题目比较简单，但是用普通的循环肯定很难解决，因为链表的存储空间不是紧挨着的，我们可以定义两个向量，从头走到尾分别把每个节点对应的值存下来，求出向量的长度，然后利用循环将上一个向量中的元素逆序存入这个数组，最后返回即可。<br>&ensp;&ensp;还有一种思路就是只使用一个向量，用一下C++高级容器中的反向迭代器</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># two vectors</div><div class="line">class Solution&#123;</div><div class="line">public:</div><div class="line">    vector &lt;int&gt; arr1, arr2;</div><div class="line">    while(head != NULL)&#123;</div><div class="line">        <span class="comment">//cout&lt;&lt;head-&gt;val&lt;&lt;endl;</span></div><div class="line">        arr1.push_back(head-&gt;val);</div><div class="line">        head = head-&gt;next;</div><div class="line">     &#125;</div><div class="line">     for(int i = 0; i &lt; arr1.size(); i++)&#123;</div><div class="line">          arr2.push_back(arr1[arr1.size()-1-i]);</div><div class="line">          cout&lt;&lt;arr2[i]&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">     return arr2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># one vector</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        vector&lt;int&gt; v;</div><div class="line">                        </div><div class="line">        ListNode *p = head;</div><div class="line">        while (<span class="selector-tag">p</span> != nullptr) &#123;</div><div class="line">           v.push_back(p-&gt;val);</div><div class="line">           p = p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//反向迭代器创建临时对象</span></div><div class="line">        return vector&lt;int&gt;(v.rbegin(), v.rend());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：输入一个链表，从尾到头打印链表每个节点的值。&lt;br&gt;&lt;img src=&quot;/2017/12/18/剑指Offer-3：链表/fg.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台：&lt;a href=&quot;https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;amp;tqId=11156&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="链表，剑指Offer" scheme="http://winterfu.github.io/tags/%E9%93%BE%E8%A1%A8%EF%BC%8C%E5%89%91%E6%8C%87Offer/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(二）：替换空格</title>
    <link href="http://winterfu.github.io/2017/12/18/%E5%89%91%E6%8C%87Offer-2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/"/>
    <id>http://winterfu.github.io/2017/12/18/剑指Offer-2：替换空格/</id>
    <published>2017-12-18T08:38:29.000Z</published>
    <updated>2017-12-18T09:11:40.065Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><img src="/2017/12/18/剑指Offer-2：替换空格/sd.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台： <a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;最简单的方法就是从头到尾遍历，但是时间复杂度为O（n^2)。<br>&ensp;&ensp;另外一种是：先遍历一次字符串，记录下字符串的长度和空格的数量，这样我们就可以得到新的字符串的总长度了。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。很简单我们直接使用指针去做就好了，还有一点比较重要的就是注意字符串末尾的”\0”.</p><h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="comment">//length为系统规定字符串输出的最大长度，固定为一个常数</span></div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str, int length)&#123;</div><div class="line">        int blankNumber = 0; //空格的数量</div><div class="line">        int oldstringLen; //记录原字符串的长度</div><div class="line"></div><div class="line">        <span class="comment">//首先遍历原字符串，找出字符串的长度以及其中的空格数量</span></div><div class="line">        for (oldstringLen = 0; str[oldstringLen] != '\0'; oldstringLen++)&#123;</div><div class="line">            <span class="keyword">if</span> (str[oldstringLen] == <span class="string">' '</span>)</div><div class="line">                blankNumber++;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">//根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度</span></div><div class="line">        int newstringLen = oldstringLen + blankNumber * 2; //新字符串的长度</div><div class="line">        <span class="keyword">if</span> (newstringLen&gt;length)</div><div class="line">            return;</div><div class="line">        str[newstringLen] = '\0'; //此行很重要，因为原字符串最后一个字符为'\0'</div><div class="line"></div><div class="line">        <span class="comment">//设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置</span></div><div class="line">        int point1 = oldstringLen - 1, point2 = newstringLen - 1; //因为'\0'已经手工加到最后新串的最后一个字符，所以减1咯</div><div class="line"></div><div class="line">        while (point1 &gt;= <span class="number">0</span> &amp;&amp; point2&gt;point1)&#123; </div><div class="line"><span class="comment">//两指针相同时，跳出循环</span></div><div class="line">            <span class="keyword">if</span> (str[point1] == <span class="string">' '</span>)&#123; </div><div class="line"><span class="comment">//如果point1指向为空格，那么从point2开始赋值“02%”</span></div><div class="line">                str[point2--] = '0';</div><div class="line">                str[point2--] = '2';</div><div class="line">                str[point2--] = '%';</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>    </div><div class="line"><span class="comment">//如果point1指向内容不为空格，那么将内容赋值给point2指向的位置</span></div><div class="line">                str[point2--] = str[point1];</div><div class="line">            point1--; //不管是if还是else都要把point1前移,为了下一次的执行</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。&lt;br&gt;&lt;img src=&quot;/2017/12/18/剑指Offer-2：替换空格/sd.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp;剑指Offer的刷题笔记。&lt;br&gt;&amp;ensp;&amp;ensp;刷题平台： &lt;a href=&quot;https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;amp;tqId=11155&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="字符串，查找，替换" scheme="http://winterfu.github.io/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2%EF%BC%8C%E6%9F%A5%E6%89%BE%EF%BC%8C%E6%9B%BF%E6%8D%A2/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer(一)：二维数组的查找</title>
    <link href="http://winterfu.github.io/2017/12/18/%E5%89%91%E6%8C%87Offer-1%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://winterfu.github.io/2017/12/18/剑指Offer-1：二维数组的查找/</id>
    <published>2017-12-18T07:53:37.000Z</published>
    <updated>2017-12-18T09:11:37.990Z</updated>
    
    <content type="html"><![CDATA[<p>摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/225H.jpg" alt=""></p><h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。<br>刷题平台： <a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p><h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;两种思路，一种是：把每一行看成有序递增的数组，利用二分查找，通过遍历每一行找到答案，时间复杂度是nlogn。<br>&ensp;&ensp;另外一种是：每次将二维数组矩阵的中最右上角(或者左下角）的数字与要查找的数字比较，基于二维数组从左到右从上到下递增，那么当最右上角的数字大于目标数字就可以去掉该列，当最右边的数字小于目标数字的时候就去掉该行，如此遍历查找。</p><h4 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a><strong>2、举例</strong></h4><p>&ensp;&ensp; 如果在一个二维数组中找到数字7那么就返回True，否则返回False，这里我们只对第二种方法进行演示。<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/aa.png" alt=""><br>&ensp;&ensp; 查找过程如下：<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/bb.png" alt=""></p><h4 id="3、具体实现"><a href="#3、具体实现" class="headerlink" title="3、具体实现"></a><strong>3、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">boolean Find(vector&lt;vector&lt;int&gt; &gt; array, int target) &#123;</div><div class="line">        int rows = array.size();</div><div class="line">        int cols = array[0].size();</div><div class="line"><span class="keyword">if</span>(!array.empty() &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; cols &gt;<span class="number">0</span>)&#123;</div><div class="line">        int row = 0;</div><div class="line">int col = cols -1;</div><div class="line">while(row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</div><div class="line">            <span class="keyword">if</span>(target == array[row][col])</div><div class="line">                return true;</div><div class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])</div><div class="line">                --col;</div><div class="line">            <span class="keyword">else</span></div><div class="line">                ++row;</div><div class="line">        &#125;</div><div class="line">&#125;</div><div class="line">        return false;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;br&gt;&lt;img src=&quot;/2017/12/18/剑指Offer-1：二维数组的查找/225H.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3 id=&quot;一、前言&quot;&gt;&lt;a href=&quot;#一、前言&quot; class=&quot;headerlink&quot; title=&quot;一、前言&quot;&gt;&lt;/a&gt;&lt;strong&gt;一、前言&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&amp;ensp;&amp;ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。&lt;br&gt;刷题平台： &lt;a href=&quot;https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;amp;tqId=11154&amp;amp;tPage=1&amp;amp;rp=1&amp;amp;ru=/ta/coding-interviews&amp;amp;qru=/ta/coding-interviews/question-ranking&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;牛客网&lt;/a&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="算法基础" scheme="http://winterfu.github.io/categories/%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="数组，查找" scheme="http://winterfu.github.io/tags/%E6%95%B0%E7%BB%84%EF%BC%8C%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>那些让整个人都通透了的回复</title>
    <link href="http://winterfu.github.io/2017/11/30/%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%95%B4%E4%B8%AA%E4%BA%BA%E9%83%BD%E9%80%9A%E9%80%8F%E4%BA%86%E7%9A%84%E5%9B%9E%E5%A4%8D/"/>
    <id>http://winterfu.github.io/2017/11/30/那些让整个人都通透了的回复/</id>
    <published>2017-11-30T02:54:52.000Z</published>
    <updated>2017-11-30T07:32:08.912Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/30/那些让整个人都通透了的回复/about.jpg" alt=""></p><p>1、交朋友的标准是什么？<br>答：出世的智者，入世的强者，或者正常而阳光的普通人。</p><p>2、男性更看重女性的身材、脸蛋，还是思想？<br>答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。</p><p>3、“别让孩子输在起跑线上”有道理吗？<br>答：一辈子都要和别人去比较，是人生悲剧的源头。<br><a id="more"></a></p><p>4、做哪些事情可以提升生活品质？<br>答：定期扔东西。</p><p>5、结婚以后两个人在一起最重要的是什么？<br>答：就当这婚还没结。</p><p>6、怎么反驳“你行你上啊”的逻辑？<br>答：“我评论个电冰箱，自己还得会制冷啊？”</p><p>7、把学费拿来念书还是环游世界更合适？为什么？<br>答：读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。</p><p>8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？<br>答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨……</p><p>9、你心中的完美爱情是怎么样的？<br>答：可以有不完美。</p><p>10、异国长期生活，改变了你的哪些“是非观”？<br>答：很多事情只是不同，并无是非。</p><p>11、是不是一个人越成熟就越难爱上一个人？<br>答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。</p><p>12、如何让这个世界变得美好？<br>答：把你自己变得更美好。</p><p>13、苦难有什么价值？<br>答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。</p><p>14、如何反驳“现实点，这个社会就是这样”？<br>答：“你是怎样，你的世界就是怎样。”</p><p>15、你对自由的理解是什么？<br>答：说“不”的能力。</p><p>16、怎么看待励志的书籍？<br>答：看再多，那都是别人的人生。</p><p>17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？<br>答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。</p><p>18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？<br>答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。</p><p>19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？<br>答：说服他人不要诉诸理性，应求于利益。</p><p>20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？<br>答：夸奖他人。</p><p>21、你是如何走出人生的阴霾的？<br>答：多走几步。</p><p>22、二十六岁，工作三年却将留学三年，值得吗？<br>答：普通玩家选择标准配置，高端玩家选择自定义配置。</p><p>23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？<br>答：试图用一句话就来总结复杂的人生，是没有希望的。</p><p>24、要怎样努力，才能成为很厉害的人？<br>答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。</p><p>25、前半生与后半生的分界线是在哪里？<br>答：此时此刻。</p><p>26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？<br>答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。</p><p>27、人这一生为什么要努力？<br>答：最痛苦的事，不是失败，是我本可以。</p><p>28、在一个足够小的星球上行走，我们是在上坡还是下坡？<br>答：你感觉累就是上坡，感觉轻松就是下坡。</p><p>29、听过最落寞的一句话或诗句是什么？<br>答：不如意事常八九，可与言者无二三。</p><p>30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？<br>答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适</p><p>31、三十岁才开始学习编程靠谱吗？<br>答：种一棵树最好的时间是十年前，其次是现在。</p><p>32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？<br>答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。</p><p>33、省钱的好办法有哪些？<br>答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。</p><p>34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？<br>答：知道做不到，等于不知道。</p><p>35、什么叫见过大世面？<br>答：能享受最好的，能承受最坏的。</p><p>36、科学和迷信的分界点是哪里？<br>答：我错了。</p><p>37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？<br>答：保护创意的最好方法，就是将其最好地执行。</p><p>38、员工辞职最主要的原因是什么？<br>答：钱少事多离家远，位低权轻责任重。</p><p>39、你在生活中得到过的最好的建议是什么？<br>答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。</p><p>40、哪些行为是浪费时间？<br>答：思而不学+犹豫不决。</p><p>41、最能燃起你学习激情的一句话是什么？<br>答：你不能把这个世界，让给你所鄙视的人。</p><p>42、如果好人没好报，我们为什么还要做好人？<br>答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔</p><p>43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？<br>答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。</p><p>44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？<br>答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台</p><p>45、情商不高的例子有哪些？<br>答：对陌生人毕恭毕敬，对亲近的人随意发怒……</p><p>46、如何看待“年轻的时候需要的是朋友而不是人脉”？<br>答：没有目的之交往，才能感动人。</p><p>47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？<br>答：不要低估你的能力，不要高估你的毅力。</p><p>48、有哪些我们熟知的名言其实还有后半句？<br>答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。”</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/30/那些让整个人都通透了的回复/about.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;p&gt;1、交朋友的标准是什么？&lt;br&gt;答：出世的智者，入世的强者，或者正常而阳光的普通人。&lt;/p&gt;
&lt;p&gt;2、男性更看重女性的身材、脸蛋，还是思想？&lt;br&gt;答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。&lt;/p&gt;
&lt;p&gt;3、“别让孩子输在起跑线上”有道理吗？&lt;br&gt;答：一辈子都要和别人去比较，是人生悲剧的源头。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="生活随想" scheme="http://winterfu.github.io/categories/%E7%94%9F%E6%B4%BB%E9%9A%8F%E6%83%B3/"/>
    
    
      <category term="生活，小情趣，大道理" scheme="http://winterfu.github.io/tags/%E7%94%9F%E6%B4%BB%EF%BC%8C%E5%B0%8F%E6%83%85%E8%B6%A3%EF%BC%8C%E5%A4%A7%E9%81%93%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>那些年使用Git走过的坑</title>
    <link href="http://winterfu.github.io/2017/11/28/%E9%82%A3%E4%BA%9B%E5%B9%B4%E4%BD%BF%E7%94%A8Git%E8%B5%B0%E8%BF%87%E7%9A%84%E5%9D%91/"/>
    <id>http://winterfu.github.io/2017/11/28/那些年使用Git走过的坑/</id>
    <published>2017-11-28T13:43:31.000Z</published>
    <updated>2017-11-30T07:32:45.798Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/28/那些年使用Git走过的坑/about1.jpg" alt=""></p><h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p>&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。<br>&ensp;&ensp;下面就来介绍一下Git的工作流程：</p><p>&ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。<br><a id="more"></a></p><p>&ensp;&ensp;可以看到，工作流程就是在工作区进行文件的修改，然后使用 git add 实现将修改推送到暂存区，但是这并不会被推送到版本库内。</p><p>&ensp;&ensp;最终需要通过 git commit 命令来对之前在暂存区内的更改，提交到版本库，然后就可以进行版本库到远端的传输。</p><h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol><li>如何实现将本地代码部署到GitHub上？</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. Github New Project 【ProjectName】（下称PN）</div><div class="line"><span class="number">2</span>. Copy PN的git地址</div><div class="line"><span class="number">3</span>. 切到本地终端，cd到Project下</div><div class="line"><span class="number">4</span>. git init</div><div class="line"><span class="number">5</span>. git remote add origin 【Copy的url】</div><div class="line"><span class="number">6</span>. git add .</div><div class="line"><span class="number">7</span>. git commit -m <span class="string">"Init Project"</span></div><div class="line"><span class="number">8</span>. git pull —rebase origin master（Github上New Project的时候如果初始化了READ.MD就要走这一步，否则不用；默认不会初始化的）</div><div class="line"><span class="number">9</span>. git push origin master</div></pre></td></tr></table></figure><ol><li>如何将别人GitHub上的工程下载下来然后自己修改后再上传上去？</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. git clone URL 到本地</div><div class="line"><span class="number">2</span>. 修改了本地的<span class="selector-tag">a</span>.py文件</div><div class="line"><span class="number">3</span>. git add .</div><div class="line">4. git commit -m "update a.py"     # 是为了将改动提交到本地git</div><div class="line">5. git pull —rebase origin master   # 是为了拉远端代码到本地</div><div class="line">6. git push origin master               # 是为了推本地代码到远端</div><div class="line">注意第<span class="number">5</span>步，之所以要进行，是因为可能你改动<span class="selector-tag">a</span>.py的同时，我也改动了<span class="selector-tag">a</span>.py，然后我比你先推上去这个时候你如果不pull远端的代码就直接覆盖了。</div></pre></td></tr></table></figure><ol><li>如何回退到之前的版本，并实现远端和本地的回退？</li></ol><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span><span class="selector-class">.git</span> status</div><div class="line"><span class="number">2</span>. git pull —rebase origin master</div><div class="line"><span class="number">3</span>. git status</div><div class="line"><span class="number">4</span>. git log   #找出你要回退的commit ID  </div><div class="line"><span class="number">5</span>. <span class="selector-id">#git</span> reset —hard [上一步的commitID]  当然也可以使用 --hard HEAD^ 来逐个查询</div><div class="line"><span class="number">6</span>. git status   #执行完此步后可以看你的文件是不是返回到了修改之前</div><div class="line"><span class="number">7</span>. git push origin master -f     #如果不强推可以实现那就不用加 -f</div></pre></td></tr></table></figure><p>更多重要的内容可以参照<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a>，这样将有助于更好的了解Git的相关知识，让你更便捷的管理你的文件。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/28/那些年使用Git走过的坑/about1.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;Git介绍&quot;&gt;&lt;a href=&quot;#Git介绍&quot; class=&quot;headerlink&quot; title=&quot;Git介绍&quot;&gt;&lt;/a&gt;Git介绍&lt;/h2&gt;&lt;p&gt;&amp;ensp;&amp;ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。&lt;br&gt;&amp;ensp;&amp;ensp;下面就来介绍一下Git的工作流程：&lt;/p&gt;
&lt;p&gt;&amp;ensp;&amp;ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="教程" scheme="http://winterfu.github.io/categories/%E6%95%99%E7%A8%8B/"/>
    
    
      <category term="Git,Github" scheme="http://winterfu.github.io/tags/Git-Github/"/>
    
  </entry>
  
  <entry>
    <title>Python中关于str（）函数和repr（）函数的那些事</title>
    <link href="http://winterfu.github.io/2017/11/28/Python%E4%B8%AD%E5%85%B3%E4%BA%8Estr%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E5%92%8Crepr%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/"/>
    <id>http://winterfu.github.io/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/</id>
    <published>2017-11-28T13:34:40.000Z</published>
    <updated>2017-11-30T07:37:21.073Z</updated>
    
    <content type="html"><![CDATA[<p><img src="/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/TheCoast.jpg" alt=""><br>相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。</p><p>Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。<br><a id="more"></a></p><h3 id="对于字符串：-a-‘hello-world-n’"><a href="#对于字符串：-a-‘hello-world-n’" class="headerlink" title="对于字符串：  a = ‘hello, world!\n’"></a><strong>对于字符串：  a = ‘hello, world!\n’</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">&apos;hello, world!\n&apos;     #输出的a本来的模样</div><div class="line">&gt;&gt;&gt; print(a)          #对a经过加工后输出，将转义字符进行转义</div><div class="line">hello,world!</div><div class="line">&gt;&gt;&gt; print(str(a))     #可以看到对str返回的值进行print处理，这将与直接print（a）得到相同的结果</div><div class="line">hello,world!    </div><div class="line">&gt;&gt;&gt; repr(a)           #获得一种机器阅读的形式，也就是这个变量背地里是什么样子的。</div><div class="line">&quot;&apos;hello, world!\n&apos;&quot;</div><div class="line">&gt;&gt;&gt; print(repr(a))    #对于repr返回的值进行print处理，可以看到这与直接在终端输入a，得到的是相同的结果</div><div class="line">&apos;hello,world!\n&apos;</div></pre></td></tr></table></figure><p>以上就是最基本的在字符串的显示中的使用，对应指令和输出结果及注释相信大家很容易都能看明白，接下来说一下这两个函数另外的作用。</p><p>###<strong>在类中的使用，可以定义一些在实例运行时，控制repr()函数作用在其实例上时的行为。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line"></div><div class="line">仅仅是这样的话我们进行如下操作：</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; print(t)</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;</div><div class="line">&gt;&gt;&gt; repr(t)</div><div class="line">&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;</div></pre></td></tr></table></figure><p>在类中没有方法的时候，如果直接在终端输入类的实例，不会输出任何东西的，上面显示的内容是由于类的特殊方法（基本定制型）有<strong>str</strong>()和<strong>repr</strong>()， 在print(object)和直接运行实例的时候回打印字符串。如果没有实现（覆盖）该函数，就会出现上面的结果。</p><p>那我们定义一个str函数来看看效果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line">     def __str__(self):</div><div class="line">          return &quot;ss&quot;</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;ss&apos;</div><div class="line">&gt;&gt;&gt;print(t)</div><div class="line">ss</div><div class="line">&gt;&gt;&gt;repr(t)</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div></pre></td></tr></table></figure><p>可以看到在这里直接输入t还会跟上面的例子的结果一致，但是str（t）和print(t)已经发生了改变，不难看出显示的是我们在类中定义的<strong>str</strong>()函数的返回值，而rerp(t)还是 跟上个例子一样，下面我们也来实现一个<strong>str</strong>()函数来看一看效果。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line">     def __str__(self):</div><div class="line">          return &quot;ss&quot;</div><div class="line">     def __repr__(self):</div><div class="line">          return &quot;gg&quot;</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">gg</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;ss&apos;</div><div class="line">&gt;&gt;&gt;print(t)</div><div class="line">ss</div><div class="line">&gt;&gt;&gt;repr(t)</div><div class="line">&apos;gg&apos;</div><div class="line">&gt;&gt;&gt; print(repr(t))</div><div class="line">gg</div></pre></td></tr></table></figure><p>好了，可以很清楚的明白，默认的<strong>str</strong>() <strong>repr</strong>()函数与重构后的区别，以及这两者与直接输入和经过print处理以后的关系了吧。<br>也就是直接在终端输入对象，相当于调用print（repr(oblect))函数，如果没有被复写则会出现上面最开始的那种显示形式；而print(object)函数相当于调用了print(str(object))这个函数，如果没有被复写就是使用的默认的，也会出现上面的显示结果。</p><p>下面还有一个对于<strong>repr</strong>( )函数的说明：<br>Python中这个<em>repr</em>函数，对应repr(object)这个函数，返回一个可以用来表示对象的可打印字符串：</p><blockquote><p>1.尝试生成这样一个字符串，将其传给 eval()可重新生成同样的对象 ；<br>2.否则，生成用尖括号包住的字符串，包含类型名和额外的信息(比如地址) ；<br>3.一个类(class)可以通过 <strong>repr</strong>() 成员来控制repr()函数作用在其实例上时的行为。</p></blockquote><p>Python中，有的操作符和函数是做同样的事情，原因是某些场合下函数会比操作符更适合使用，比如函数对象可作为参数传递。</p><p>希望我的文章能够帮到你，喜欢的可以点一波关注！！您的支持是博主坚持的动力~~~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/TheCoast.jpg&quot; alt=&quot;&quot;&gt;&lt;br&gt;相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。&lt;/p&gt;
&lt;p&gt;Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python学习" scheme="http://winterfu.github.io/categories/python%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="python,str,repr" scheme="http://winterfu.github.io/tags/python-str-repr/"/>
    
  </entry>
  
</feed>

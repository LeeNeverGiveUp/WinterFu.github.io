<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[剑指Offer(七)：斐波那切数列]]></title>
      <url>/2017/12/26/%E5%89%91%E6%8C%87Offer-7%EF%BC%9A%E8%8F%B2%E6%B3%A2%E9%82%A3%E5%88%87%E6%95%B0%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。<br><img src="/2017/12/26/剑指Offer-7：菲波那切数列/ppo.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/c6c7742f5ba7442aada113136ddea0c3?tpId=13&amp;tqId=11160&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;斐波那切数列，相信大家都不陌生吧，对就是那个我们小时候常做的问题，什么小兔子生兔子的问题，还有一些花的花瓣数也是符合斐波那契数列的规律的，因此也称其为“迷人的斐波那契数列”，在数学上，斐波那契数列以递归的方式定义：F(0) = 0，F(1) = 1， F(n) = F(n-1) + F(n-2) (n&gt;=2，n为正整数)</p>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:<br>1.首先我们就可以按照其定义方式，用递归的思想来实现：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        if(n&lt;=0) return 0;</div><div class="line"> if(n==1 || n==2) return 1;</div><div class="line">        return Fibonacci(n-1)+Fibonacci(n-2);</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>这里存在一个问题就是，当n比较大的时候会出现溢出的情况。</p>
<p>2.动态规划的思想</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int Fibonacci(int n) &#123;</div><div class="line">        int f = 0, g = 1;</div><div class="line">        while(n--) &#123;</div><div class="line">            g += f;</div><div class="line">            f = g - f;</div><div class="line">        &#125;</div><div class="line">        return f;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>3.全面考虑，把负数，大数，算法的复杂度，空间浪费都考虑进来</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int Fibonacci(int n) &#123;</div><div class="line">        <span class="comment">//方法1：用递归，系统会让一个超大的n来让Stack Overflow，所以</span></div><div class="line">        <span class="comment">//递归就不考虑了</span></div><div class="line">         </div><div class="line">        <span class="comment">//使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来</span></div><div class="line">        int fn1 = 1;</div><div class="line">        int fn2 = 1;</div><div class="line">         </div><div class="line">        <span class="comment">//考虑出错情况</span></div><div class="line">        <span class="keyword">if</span> (n &lt;= <span class="number">0</span>) &#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//第一和第二个数直接返回</span></div><div class="line">        if (n == 1 || n == 2) &#123;</div><div class="line">            return 1;</div><div class="line">        &#125;</div><div class="line"> </div><div class="line">        <span class="comment">//当n&gt;=3时，走这里，用迭代法算出结果</span></div><div class="line">        <span class="comment">//这里也说明了，要用三个数操作的情况，其实也可以简化为两</span></div><div class="line">        <span class="comment">//个数，从而节省内存空间</span></div><div class="line">        while (n-- &gt; <span class="number">2</span>) &#123;</div><div class="line">            fn1 += fn2;</div><div class="line">            fn2 = fn1 - fn2;</div><div class="line">        &#125;</div><div class="line">        return fn1;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>4.尾递归，递归总归来说是栈，可能导致栈溢出</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">    public int Fibonacci(int n) &#123;</div><div class="line">        return Fibonacci(n,0,1);</div><div class="line">    &#125;</div><div class="line">     </div><div class="line">     </div><div class="line">    private static int Fibonacci(int n,int acc1,int acc2)&#123;</div><div class="line">        if(n==0) return 0;</div><div class="line">        if(n==1) return acc2;</div><div class="line">        else     return Fibonacci(n - 1, acc2, acc1 + acc2);</div><div class="line">         </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp;人生苦短，我用Python:<br>1.递归实现</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">def fib(n):</div><div class="line">    return <span class="number">1</span> <span class="keyword">if</span> n&lt;=<span class="number">1</span> <span class="keyword">else</span> fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)              #很简单的一个三目运算符实现</div><div class="line"></div><div class="line">def fib(n):</div><div class="line">    dic = &#123; <span class="number">0</span>:<span class="number">1</span>, <span class="number">1</span>: <span class="number">1</span>&#125;</div><div class="line">    <span class="keyword">if</span> n&lt;=<span class="number">1</span>:</div><div class="line">        return dict[n]</div><div class="line">    retrun fib(n-<span class="number">1</span>)+fib(n-<span class="number">2</span>)</div></pre></td></tr></table></figure>
<p>PS：递归还有一个缺点就是需要进行很多次重复的运算</p>
<p>2.完美实现方案1</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">def fib1(n):</div><div class="line">    stack =[]</div><div class="line">    <span class="keyword">if</span> n==<span class="number">0</span> or n==<span class="number">1</span>:</div><div class="line">       return <span class="number">1</span></div><div class="line">    <span class="keyword">else</span>:</div><div class="line">        stack.append(<span class="number">1</span>)</div><div class="line">        stack.append(<span class="number">1</span>)</div><div class="line">        <span class="keyword">for</span> <span class="selector-tag">i</span> <span class="keyword">in</span> range(<span class="number">2</span>,n):</div><div class="line">            stack.append(stack[i-<span class="number">1</span>] + stack[i-<span class="number">2</span>])</div><div class="line">        retrun stack</div></pre></td></tr></table></figure>
<p>3.完美实现方案2</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">def fib2(number):</div><div class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    result = []</div><div class="line">    while y &lt; number:</div><div class="line">        result.append(y)</div><div class="line">        x, y = y, x+y</div><div class="line">    return result</div></pre></td></tr></table></figure>
<p>4.完美实现方案3，吧其编程一个生成器的形式，可以使用循环将其输出出来</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">def fib3():</div><div class="line">    x, y = <span class="number">0</span>, <span class="number">1</span></div><div class="line">    while True:</div><div class="line">        yeild x</div><div class="line">        x, y = y, x+y</div><div class="line"></div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    import itertools</div><div class="line">    print(list(itertools.islice(fib(), <span class="number">10</span>))</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 递归,循环 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(六)：旋转数组的最小数字]]></title>
      <url>/2017/12/25/%E5%89%91%E6%8C%87Offer-6%EF%BC%9A%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97/</url>
      <content type="html"><![CDATA[<p>摘要：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。<br><img src="/2017/12/25/剑指Offer-6：旋转数组的最小数字/ppo.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/9f3231a991af4f55b95579b44b7a01ba?tpId=13&amp;tqId=11159&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;首先要注意有无重复数字，也就是是否严格递增。这是一道二分查找的变形题目，旋转后的之后的数字实际上可以划分为两个有序的子数组：前面的数组中的元素大小都大于后面子数组中的元素。<br>&ensp;&ensp;不难发现实际上最小的元素就是两字子数组的分界线。本题目给出的数组一定程度上是排好序的，因此我们可以采用二分法来查找。</p>
<ol>
<li>我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。但是如果不旋转，第一个元素肯定是小于最后一个元素的。</li>
<li>找到数组的中间元素：1&gt;中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。移动之后，第一个指针仍然位于前面的递增数组中。 2&gt;中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。移动后，第二个指针仍然位于后面的递增数组中。这样即可缩小寻找的范围。</li>
<li>按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。</li>
</ol>
<p>&ensp;&ensp;到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。因此这一道题目比上一道题目多了些特殊情况：</p>
<p>&ensp;&ensp;我们看一组例子：｛1，0，<font color="red">1</font>，<font color="green">1</font>，<font color="green">1</font>｝ 和 ｛<font color="purple">1</font>，<font color="purple">1</font>， <font color="red">1</font>，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。</p>
<p>&ensp;&ensp;这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。</p>
<p>&ensp;&ensp;因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（<font color="green">绿色表示</font>）还是属于后面的子数组（<font color="purple">紫色表示</font>）。也就无法移动指针来缩小查找范围了。</p>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;vector&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;string&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;stack&gt;</div><div class="line"><span class="selector-id">#include</span> &lt;algorithm&gt;</div><div class="line">using namespace std;</div><div class="line"> </div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123;</div><div class="line">        int size = rotateArray.size();</div><div class="line">        <span class="keyword">if</span>(size == <span class="number">0</span>)&#123;</div><div class="line">            return 0;</div><div class="line">        &#125;</div><div class="line">        int <span class="attribute">left</span> = <span class="number">0</span>,right = size - <span class="number">1</span>;</div><div class="line">        int mid = 0;</div><div class="line">        while(rotateArray[<span class="attribute">left</span>] &gt;= rotateArray[right])&#123;</div><div class="line">            <span class="comment">// 分界点</span></div><div class="line">            <span class="keyword">if</span>(<span class="attribute">right</span> - left == <span class="number">1</span>)&#123;</div><div class="line">                mid = <span class="attribute">right</span>;</div><div class="line">                break;</div><div class="line">            &#125;</div><div class="line">            mid = <span class="attribute">left</span> + (right - left) / <span class="number">2</span>;</div><div class="line">            <span class="comment">// rotateArray[left] rotateArray[right] rotateArray[mid]三者相等</span></div><div class="line">            <span class="comment">// 无法确定中间元素是属于前面还是后面的递增子数组</span></div><div class="line">            <span class="comment">// 只能顺序查找</span></div><div class="line">            <span class="keyword">if</span>(rotateArray[<span class="attribute">left</span>] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])&#123;</div><div class="line">                return MinOrder(rotateArray,<span class="attribute">left</span>,right);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 中间元素位于前面的递增子数组</span></div><div class="line">            <span class="comment">// 此时最小元素位于中间元素的后面</span></div><div class="line">            <span class="keyword">if</span>(rotateArray[mid] &gt;= rotateArray[<span class="attribute">left</span>])&#123;</div><div class="line">                <span class="attribute">left</span> = mid;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">// 中间元素位于后面的递增子数组</span></div><div class="line">            <span class="comment">// 此时最小元素位于中间元素的前面</span></div><div class="line">            <span class="keyword">else</span>&#123;</div><div class="line">                <span class="attribute">right</span> = mid;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return rotateArray[mid];</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    <span class="comment">// 顺序寻找最小值</span></div><div class="line">    int MinOrder(vector&lt;int&gt; &amp;num,int <span class="attribute">left</span>,int right)&#123;</div><div class="line">        int result = num[<span class="attribute">left</span>];</div><div class="line">        <span class="keyword">for</span>(int <span class="selector-tag">i</span> = <span class="attribute">left</span> + <span class="number">1</span>;<span class="selector-tag">i</span> &lt; <span class="attribute">right</span>;++i)&#123;</div><div class="line">            <span class="keyword">if</span>(num[i] &lt; result)&#123;</div><div class="line">                result = num[i];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        return result;</div><div class="line">    &#125;</div><div class="line">&#125;;</div><div class="line"> </div><div class="line">int main()&#123;</div><div class="line">    Solution s;</div><div class="line">    <span class="comment">//vector&lt;int&gt; num = &#123;0,1,2,3,4,5&#125;;</span></div><div class="line">    <span class="comment">//vector&lt;int&gt; num = &#123;4,5,6,7,1,2,3&#125;;</span></div><div class="line">    vector&lt;int&gt; num = &#123;2,2,2,2,1,2&#125;;</div><div class="line">    int result = s.minNumberInRotateArray(num);</div><div class="line">    <span class="comment">// 输出</span></div><div class="line">    cout&lt;&lt;result&lt;&lt;endl;</div><div class="line">    return 0;</div><div class="line">	&#125;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp;人生苦短，我用Python:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"># -*- coding: utf-8 -*-</div><div class="line">def find_rotation_array_min(roation_array):</div><div class="line">    n = len(roation_array)</div><div class="line">    <span class="keyword">if</span> roation_array[<span class="number">0</span>] &lt; roation_array[-<span class="number">1</span>]:</div><div class="line">        return <span class="number">0</span></div><div class="line">    <span class="attribute">left</span> = <span class="number">0</span></div><div class="line">    <span class="attribute">right</span> = n-<span class="number">1</span></div><div class="line">    while roation_array[<span class="attribute">left</span>] &gt;= roation_array[right]:</div><div class="line">        <span class="keyword">if</span> <span class="attribute">right</span>-left == <span class="number">1</span>:</div><div class="line">            mid = <span class="attribute">right</span></div><div class="line">            break</div><div class="line">        mid = <span class="attribute">left</span> + int((right - left) / <span class="number">2</span>)</div><div class="line">        <span class="keyword">if</span>(roation_array[<span class="attribute">left</span>]==roation_array[right] and roation_array[left] == roation_array[mid]):</div><div class="line">            return min(roation_array)</div><div class="line">        <span class="keyword">if</span>(roation_array[mid] &gt;= roation_array[<span class="attribute">left</span>]):</div><div class="line">            <span class="attribute">left</span> =mid</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            <span class="attribute">right</span>=mid</div><div class="line">    return roation_array[mid]</div><div class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</div><div class="line">    s = [<span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>, <span class="number">2</span>]</div><div class="line">    <span class="selector-tag">q</span> = [<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>,<span class="number">2</span>]</div><div class="line">    print(find_rotation_array_min(s), find_rotation_array_min(q))</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组,查找,排序 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浅谈神经网络中激励函数的作用]]></title>
      <url>/2017/12/25/%E6%B5%85%E8%B0%88%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C%E4%B8%AD%E6%BF%80%E5%8A%B1%E5%87%BD%E6%95%B0%E7%9A%84%E4%BD%9C%E7%94%A8/</url>
      <content type="html"><![CDATA[<p><img src="/2017/12/25/浅谈神经网络中激励函数的作用/ff.jpg" alt=""></p>
<h3 id="什么是激活函数？"><a href="#什么是激活函数？" class="headerlink" title="什么是激活函数？"></a><strong>什么是激活函数？</strong></h3><p>&ensp;&ensp;我想z这一点也不用多说，无论是搞机器学习还是深度学习的对于激活函数这个名词已经再熟悉不过了，因为搭建网络的时候都会要用到它，虽然我们无时无刻都在使用它，但是我们真的知其然也知其所以然么？</p>
<ul>
<li>首先问自己一个问题，在解决复杂问题用的神经网络模型中如果没有激活函数可以么？</li>
<li>很显然，不可以！！！</li>
</ul>
<p>&ensp;&ensp;那么肯定又会有人问了为什么不可以，那有无激活函数又有什么区别，激活函数的作用又是什么呢？</p>
<a id="more"></a>
<p>&ensp;&ensp;且听我慢慢道来：<br>&ensp;&ensp;首先回答，为什么不可以，神经网络之所以很强大，能够解决很多复杂问题，很重要的一点就是其引入了非线性，那么是通过什么引入的呢？没错就是你想的那样，通过激活函数，这样它才能够解决一些复杂的非线性问题，如果没有激活函数，或者是线性激活函数，那么就跟普通的线性方程别无二致了，这肯定不是我们想要的。</p>
<h3 id="激活函数的作用"><a href="#激活函数的作用" class="headerlink" title="激活函数的作用"></a><strong>激活函数的作用</strong></h3><ul>
<li>激活函数是用来加入非线性因素的，解决线性模型所不能解决的问题</li>
<li>激活函数可以用来组合训练数据的特征，使特征充分组合</li>
</ul>
<p>&ensp;&ensp;在这里第一个特点上面我们也提到了，主要是用来引入非线性，提高神经网络的表达能力，更好的解决复杂的非线性问题。单层感知机解决不了异或问题，多层感知机可以解决异或但是再加入一点非线性其能力还是很弱，这已经是个老生常谈的话题了。</p>
<p>&ensp;&ensp;下面主要从第二个特点我们进行说明一下：</p>
<p>&ensp;&ensp;首先我们看一个简单的感知机的例子：<br><img src="/2017/12/25/浅谈神经网络中激励函数的作用/dd.png" alt=""></p>
<p>&ensp;&ensp;其中，x1和x2为特征输入，x3 = w1 <em> x1 + w2 </em> x2，激活函数采用sigmoid函数，公式表达式如下：<br><img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large g(x)=\frac{1}{1+e^{-x}}" style="border:none;"></p>
<p>则<img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large g(x3)=\frac{1} {1 + e^{-x3}}" style="border:none;"></p>
<p>&ensp;&ensp;此时，我们可能看不出什么不同，下面我们进行泰勒展开，</p>
<p><img src="http://chart.googleapis.com/chart?cht=tx&chl=\Large e^x=1 + \frac{1} {1!}x + \frac{1} {2!} x^2 + \frac{1} {3!} x^3 + o(x^3)" style="border:none;"></p>
<p>&ensp;&ensp;通过泰勒展开。我们不难看到，我们已经构造出立方激活函数的形式了，我们能够看到，将x3带入到激活函数中时，将激活函数中的指数项按照泰勒级数展开后，就会有平方项，立方项，有更高的项，这些能够把输入特征进行亮亮组合，进行三三组合或者其他组合。</p>
<h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h3><p>&ensp;&ensp;激活函数在神经网络模型的构建中必不可少，能够引入一定的非线性因素，增强网络的表达能力；此外还可以把原来需要领域知识的专家对特征进行组合的情况，在激活函数运算后，其实也能够起到特征组合的作用。（只要激活函数中能有用泰勒级数展开的函数，就可以对特征起到组合的作用）</p>
]]></content>
      
        <categories>
            
            <category> 机器学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 激活函数,sigmoid </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(五)：栈和队列]]></title>
      <url>/2017/12/21/%E5%89%91%E6%8C%87Offer-5%EF%BC%9A%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97/</url>
      <content type="html"><![CDATA[<p>摘要：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。<br><img src="/2017/12/21/剑指Offer-5：栈和队列/ppo.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/54275ddae22f475981afa2244dd448c6?tpId=13&amp;tqId=11158&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题目首先要知道队列和栈各自的特点，那么接下来就按照这种特点去设计即可：</p>
<ul>
<li>入队：将元素进栈A</li>
<li>出队：判断栈B是否为空，如果为空，则将栈A中所有的元素pop，并push进栈B，栈B出栈；如果不为空则栈B直接出栈。</li>
</ul>
<p>&ensp;&ensp;这里同样可以用两个队列实现一个栈的功能：</p>
<ul>
<li>入栈：将元素进队列A</li>
<li>出栈：判断队列A中元素个数是否为1，如果等于1则出队列，否则将队列A中的元素，一次出队列并放入队列B中，直到队列A中的元素留下最后一个，然后队列A出队列，再把队列B中的元素出队列一次放入队列A中。</li>
</ul>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line">class Solution</div><div class="line">&#123;</div><div class="line">public:</div><div class="line">    void push(int node) &#123;</div><div class="line">        stack1.push(node);</div><div class="line">    &#125;</div><div class="line">    int pop() &#123;</div><div class="line">        int temp;</div><div class="line">        <span class="keyword">if</span>(stack2.empty())&#123;</div><div class="line">            while(!stack1.empty())&#123;</div><div class="line">                temp = stack1.<span class="attribute">top</span>();</div><div class="line">                stack2.push(temp);</div><div class="line">                stack1.pop();</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        temp = stack2.<span class="attribute">top</span>();</div><div class="line">        stack2.pop();</div><div class="line">        return temp;</div><div class="line">    &#125;</div><div class="line">private:</div><div class="line">    stack&lt;int&gt; stack1;</div><div class="line">    stack&lt;int&gt; stack2;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp;人生苦短，我用Python:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class Solution:</div><div class="line">    def __init__(self):</div><div class="line">        self<span class="selector-class">.stackA</span> = [ ]</div><div class="line">        self<span class="selector-class">.stackB</span> = [ ]</div><div class="line">         </div><div class="line">    def push(self, node):</div><div class="line">        # write code here</div><div class="line">        self<span class="selector-class">.stackA</span><span class="selector-class">.append</span>(node)</div><div class="line">         </div><div class="line">    def pop(self):</div><div class="line">        # return xx</div><div class="line">        <span class="keyword">if</span> self<span class="selector-class">.stackB</span>:</div><div class="line">            return self<span class="selector-class">.stackB</span><span class="selector-class">.pop</span>()</div><div class="line">        elif not self<span class="selector-class">.stackA</span>:</div><div class="line">            return None</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            while self<span class="selector-class">.stackA</span>:</div><div class="line">                self<span class="selector-class">.stackB</span><span class="selector-class">.append</span>(self<span class="selector-class">.stackA</span><span class="selector-class">.pop</span>())</div><div class="line">            return self<span class="selector-class">.stackB</span><span class="selector-class">.pop</span>()</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 队列,栈 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[全球AI挑战赛之场景分类赛后总结篇]]></title>
      <url>/2017/12/21/%E5%85%A8%E7%90%83AI%E6%8C%91%E6%88%98%E8%B5%9B%E4%B9%8B%E5%9C%BA%E6%99%AF%E5%88%86%E7%B1%BB%E8%B5%9B%E5%90%8E%E6%80%BB%E7%BB%93%E7%AF%87/</url>
      <content type="html"><![CDATA[<p><img src="/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/ai.png" alt=""><br>&ensp;&ensp;全球AI挑战赛已经落下帷幕近半个月的时间了，虽然没拿到太好的名次，但是这次的实战确实是学到了不少东西，也填了不少的坑，也算是为以后的学习道路除去了很多绊脚石吧，这次和puke同学一起摸爬滚打了好些昼夜，最终坚持到了最后，下面就分享一下我们在这次比赛中的经历以及一些对于遇到的那些问题的解决方案，小的tricks吧。<br><a id="more"></a></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;首先简单说一下这个比赛，<a href="https://challenger.ai/" target="_blank" rel="external">全球AI挑战赛</a>我门选择的是场景分类这个题目，主要的任务就是将所给图片进行80场景分类，之前的ImageNet也是做过类似的比赛数据集是places-365或者200之类的，这次的数据集规模相对ImageNet的规模要小，但是图片质量还是有的保障的，我们也是大致看了一下比赛数据集中的图片，训练集5W+张，验证集7000+张，测试集分为AB榜进行测试，规模和验证集差不多，图片二义性很强，而且存在严重的不均衡现象，有些图片真的是人都很难去区分，但是机器做的很不错，不得不又得吹嘘一把DeepLearning的强大啊，哈哈哈！</p>
<h3 id="二、快速接入"><a href="#二、快速接入" class="headerlink" title="二、快速接入"></a><strong>二、快速接入</strong></h3><p>&ensp;&ensp;<a href="https://challenger.ai/competition/scene/subject" target="_blank" rel="external">下载数据集</a><br>&ensp;&ensp;<a href="https://github.com/puke3615/SceneClassify" target="_blank" rel="external">代码链接</a></p>
<h3 id="三、项目要点概述"><a href="#三、项目要点概述" class="headerlink" title="三、项目要点概述"></a><strong>三、项目要点概述</strong></h3><ul>
<li>支持多个单模型进行集成，可选多种集成方式</li>
<li>支持多种集成方式间的任意组合和自动择优</li>
<li>支持间断训练后在训练时权重文件的择优选择</li>
<li>支持VGG16、VGG19、Resnet50、Inception-V3、Xception、Inception-Resnet-V2等模型</li>
<li>imgaug图片数据增强库替换Keras自带的图片预处理</li>
</ul>
<h3 id="四、血泪史"><a href="#四、血泪史" class="headerlink" title="四、血泪史"></a><strong>四、血泪史</strong></h3><p> &ensp;&ensp;<strong>选好框架很重要！！！</strong></p>
<p>&ensp;&ensp;Tensorflow现在最流行的框架应该没有之一了吧，然而就是个大坑没毛病。其实这是谷歌开发的给工程师用的，对于小白或者教学来说还是用起来比较费劲，那为何还这么流行呢，毕竟是大厂，都懂得。虽然之后的Tensorflow出现了TFlearn和slim等高级库，但是还是写起来比较繁琐，所以像我这么懒的人呢还是果断抛弃了他，投向了Keras的怀抱，当然还有一些什么Caffee、Pytorch、MXnet啥的，至于为什么选了Keras我自己也讲不出来，Keras写起来很简单，也有一些已经预训练好的模型，但是同样在训练时有很多坑，不过现在已经被填平好多了，下面就来说一说这些坑（欢迎其他同学指正，补充！）</p>
<p> &ensp;&ensp;<strong>数据增强很重要！！！</strong></p>
<p>&ensp;&ensp;Keras自带的图片增强远远不够的，这里选择了imgaug这个图片数据增强库，直接上图，这种效果是目前的Keras望尘莫及的，尽可能最大限度利用当前有限的数据集。提高1~3个百分点<br><img src="/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/imgaug.png" alt=""></p>
<p>&ensp;&ensp;<strong>尽可能的去并行处理！！！</strong></p>
<p>&ensp;&ensp;训练任务交给GPU去做，新添加的imgaug图片处理方式之后，一个Epoch在1050Ti上耗时90mins+，排查发现大部分时间都在进行图片数据增强处理，于是将该部分的处理替换为多进程方式。<strong>时间从90mins降到30mins左右</strong></p>
<p>&ensp;&ensp;<strong>数据标准化很重要！！！</strong><br>&ensp;&ensp;Keras是自带的标准化都不是最合理的，首先我们要计算出整体训练集三个通道各自的mean和std而不是单个数据，更不是单个batch的。然后在训练阶段的输入数据以mean和std进行高斯处理（注意验证集也要做一样的操作，这里是为了保证同分布），<strong>提高0.5~1.0个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>Fine-tuning时别绑太紧！！！</strong></p>
<p>&ensp;&ensp;这点尤为重要！Fine-tune时松太开，可能导致训练耗时，也可能导致机器带不动；绑太紧可能导致Fixed的权重参数扼制了模型的学习能力。建议是在机器能扛得住的基础下，尽可能松绑多一些，<strong>提高2~5个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>模型选择很重要！！！</strong></p>
<p>&ensp;&ensp;糟糕的模型训练几天几夜，可能赶不上优势模型训练几个epoch。VGG16=&gt;Xception<strong>提高5~8个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>Loss降不下去时尝试调低LR！！！</strong></p>
<p>&ensp;&ensp;降不下去就调小，调下的幅度一般是5倍、10倍左右，<strong>提高1~3个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>TensorBoard监视训练状态！！！</strong></p>
<p>&ensp;&ensp;尽可能使用Tensorflow提供的Tensorboard可视化工具，方便从宏观把控训练过程。</p>
<p>&ensp;&ensp;<strong>适度过拟合是良性的！！！</strong></p>
<p>&ensp;&ensp;训练过程中一直没有过拟合，要从两方面考虑：</p>
<ul>
<li>模型太简单，拟合能力不够，这时候要考虑提高网络复杂度</li>
<li>数据增强程度太大，导致某些特征学不到。</li>
</ul>
<p>&ensp;&ensp;<strong>模型集成很重要！！！</strong></p>
<p>&ensp;&ensp;“三个臭皮匠，顶个诸葛亮”，这句话还是很有道理的，千万不要单模型一条路跑到黑，要尝试将多个模型进行集成。集成的方式可以选择投票法、均值法、按照模型Acc加权法等等，<strong>提高0.5~1.5个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>预测数据增强！！！</strong></p>
<p>&ensp;&ensp;为了确保预测结果的准确性，可以将待预测结果进行水平翻转（或随机裁取patch等）处理，将这多张孪生图片进行预测，最终结果取多个结果的均值，<strong>提高0.25~1.0个百分点</strong>。</p>
<p>&ensp;&ensp;<strong>Teamwork is necessary!!!</strong></p>
<p>&ensp;&ensp;想法x2，时间/2，还能互相讨论学习！<strong>提高0~50个百分点</strong>！</p>
]]></content>
      
        <categories>
            
            <category> Events </category>
            
        </categories>
        
        
        <tags>
            
            <tag> AI,场景识别,Keras </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(四)：树]]></title>
      <url>/2017/12/18/%E5%89%91%E6%8C%87Offer-4%EF%BC%9A%E6%A0%91/</url>
      <content type="html"><![CDATA[<p>摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。<br><img src="/2017/12/18/剑指Offer-4：树/forest.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/8a19cbe657394eeaac2f6ea9b0f6fcf6?tpId=13&amp;tqId=11157&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题首先要明白二叉树的遍历方法，主要分为前序、中序和后序三种遍历方法以及三种遍历的特点，那么就不难解决这个问题了，下面我们来讲一下思路。<br>&ensp;&ensp;先序遍历第一个位置肯定是根节点node，  中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组；<br>&ensp;&ensp;另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组，把四个数组找出来，分左右递归调用即可。</p>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></td><td class="code"><pre><div class="line"><span class="comment">/**     * Definition for binary tree     </span></div><div class="line"><span class="comment">* struct TreeNode &#123;     </span></div><div class="line"><span class="comment">*     int val;    </span></div><div class="line"><span class="comment">*     TreeNode *left;     </span></div><div class="line"><span class="comment">*     TreeNode *right;     </span></div><div class="line"><span class="comment">*     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;     </span></div><div class="line"><span class="comment">* &#125;;    </span></div><div class="line"><span class="comment">*/</span>    </div><div class="line">class Solution &#123;    </div><div class="line">public:</div><div class="line">        struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123;            </div><div class="line">            int inlen=in.size();            </div><div class="line">            <span class="keyword">if</span>(inlen==<span class="number">0</span>)                </div><div class="line">                return NULL;            </div><div class="line">            vector&lt;int&gt; left_pre,right_pre,left_in,right_in;           </div><div class="line">             <span class="comment">//创建根节点，根节点肯定是前序遍历的第一个数</span></div><div class="line">            TreeNode* head=new TreeNode(pre[0]);            </div><div class="line">            <span class="comment">//找到中序遍历根节点所在位置,存放于变量gen中  </span></div><div class="line">            int gen=0;</div><div class="line">            for(int i=0;i&lt;inlen;i++)           </div><div class="line">     &#123;               </div><div class="line">                 <span class="keyword">if</span> (<span class="keyword">in</span>[i]==pre[<span class="number">0</span>])                </div><div class="line">                &#123;                    </div><div class="line">                    gen=i;                    </div><div class="line">                    break;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边            </span></div><div class="line">            <span class="comment">//利用上述这点，对二叉树节点进行归并  		</span></div><div class="line">            for(int i=0;i&lt;gen;i++)            </div><div class="line">            &#123;</div><div class="line">                left_in.push_back(in[i]);                </div><div class="line">                left_pre.push_back(pre[i+1]);//前序第一个为根节点</div><div class="line">            &#125;</div><div class="line">            for(int i=gen+1;i&lt;inlen;i++)            </div><div class="line">            &#123;                </div><div class="line">                right_in.push_back(in[i]);                </div><div class="line">                right_pre.push_back(pre[i]);</div><div class="line">            &#125;</div><div class="line">            <span class="comment">//和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树</span></div><div class="line">            <span class="comment">//递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点</span></div><div class="line">           head-&gt;<span class="attribute">left</span>=reConstructBinaryTree(left_pre,left_in);</div><div class="line">           head-&gt;<span class="attribute">right</span>=reConstructBinaryTree(right_pre,right_in);</div><div class="line">           return head;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div></pre></td></tr></table></figure>
<p>&ensp;&ensp; 人生苦短，我用Python:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"># -*- coding:utf-8 -*-</div><div class="line">class TreeNode:</div><div class="line">	def __init__(self, x):</div><div class="line">        self<span class="selector-class">.val</span> = x</div><div class="line">        self<span class="selector-class">.left</span> = None</div><div class="line">		self<span class="selector-class">.right</span> = None</div><div class="line">		</div><div class="line">class Solution:</div><div class="line">    # 返回构造的TreeNode根节点</div><div class="line">	def reConstructBinaryTree(self, pre, tin):</div><div class="line">        # write code here</div><div class="line">        <span class="keyword">if</span> len(pre) == <span class="number">0</span>:</div><div class="line">            return None</div><div class="line">        elif len(pre) == <span class="number">1</span>:</div><div class="line">            return TreeNode(pre[<span class="number">0</span>])</div><div class="line">        <span class="keyword">else</span>:</div><div class="line">            ans = TreeNode(pre[<span class="number">0</span>])</div><div class="line">            ans<span class="selector-class">.left</span> = self.reConstructBinaryTree(pre[<span class="number">1</span>:tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>], tin[:tin.index(pre[<span class="number">0</span>])])</div><div class="line">            ans<span class="selector-class">.right</span> = self.reConstructBinaryTree(pre[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:], tin[tin.index(pre[<span class="number">0</span>])+<span class="number">1</span>:])</div><div class="line">            return ans</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 树,重建 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(三)：链表]]></title>
      <url>/2017/12/18/%E5%89%91%E6%8C%87Offer-3%EF%BC%9A%E9%93%BE%E8%A1%A8/</url>
      <content type="html"><![CDATA[<p>摘要：输入一个链表，从尾到头打印链表每个节点的值。<br><img src="/2017/12/18/剑指Offer-3：链表/fg.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台：<a href="https://www.nowcoder.com/practice/d0267f7f55b3412ba93bd35cfa8e8035?tpId=13&amp;tqId=11156&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 输入一个链表，从尾到头打印链表每个节点的值。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;这道题目比较简单，但是用普通的循环肯定很难解决，因为链表的存储空间不是紧挨着的，我们可以定义两个向量，从头走到尾分别把每个节点对应的值存下来，求出向量的长度，然后利用循环将上一个向量中的元素逆序存入这个数组，最后返回即可。<br>&ensp;&ensp;还有一种思路就是只使用一个向量，用一下C++高级容器中的反向迭代器</p>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></td><td class="code"><pre><div class="line"># two vectors</div><div class="line">class Solution&#123;</div><div class="line">public:</div><div class="line">    vector &lt;int&gt; arr1, arr2;</div><div class="line">    while(head != NULL)&#123;</div><div class="line">        <span class="comment">//cout&lt;&lt;head-&gt;val&lt;&lt;endl;</span></div><div class="line">        arr1.push_back(head-&gt;val);</div><div class="line">        head = head-&gt;next;</div><div class="line">     &#125;</div><div class="line">     for(int i = 0; i &lt; arr1.size(); i++)&#123;</div><div class="line">          arr2.push_back(arr1[arr1.size()-1-i]);</div><div class="line">          cout&lt;&lt;arr2[i]&lt;&lt;endl;</div><div class="line">     &#125;</div><div class="line">     return arr2;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"># one vector</div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123;</div><div class="line">        vector&lt;int&gt; v;</div><div class="line">                        </div><div class="line">        ListNode *p = head;</div><div class="line">        while (<span class="selector-tag">p</span> != nullptr) &#123;</div><div class="line">           v.push_back(p-&gt;val);</div><div class="line">           p = p-&gt;next;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">//反向迭代器创建临时对象</span></div><div class="line">        return vector&lt;int&gt;(v.rbegin(), v.rend());</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 链表，剑指Offer </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(二）：替换空格]]></title>
      <url>/2017/12/18/%E5%89%91%E6%8C%87Offer-2%EF%BC%9A%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC/</url>
      <content type="html"><![CDATA[<p>摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。<br><img src="/2017/12/18/剑指Offer-2：替换空格/sd.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp;剑指Offer的刷题笔记。<br>&ensp;&ensp;刷题平台： <a href="https://www.nowcoder.com/practice/4060ac7e3e404ad1a894ef3e17650423?tpId=13&amp;tqId=11155&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;最简单的方法就是从头到尾遍历，但是时间复杂度为O（n^2)。<br>&ensp;&ensp;另外一种是：先遍历一次字符串，记录下字符串的长度和空格的数量，这样我们就可以得到新的字符串的总长度了。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\n”），里面有两个空格，因此替换之后字符串的长度是18。很简单我们直接使用指针去做就好了，还有一点比较重要的就是注意字符串末尾的”\0”.</p>
<h4 id="2、具体实现"><a href="#2、具体实现" class="headerlink" title="2、具体实现"></a><strong>2、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line"><span class="selector-id">#include</span> &lt;iostream&gt;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line"><span class="comment">//length为系统规定字符串输出的最大长度，固定为一个常数</span></div><div class="line">class Solution &#123;</div><div class="line">public:</div><div class="line">    void replaceSpace(char *str, int length)&#123;</div><div class="line">        int blankNumber = 0; //空格的数量</div><div class="line">        int oldstringLen; //记录原字符串的长度</div><div class="line">		</div><div class="line">        <span class="comment">//首先遍历原字符串，找出字符串的长度以及其中的空格数量</span></div><div class="line">        for (oldstringLen = 0; str[oldstringLen] != '\0'; oldstringLen++)&#123;</div><div class="line">            <span class="keyword">if</span> (str[oldstringLen] == <span class="string">' '</span>)</div><div class="line">                blankNumber++;</div><div class="line">        &#125;</div><div class="line">		</div><div class="line">        <span class="comment">//根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度</span></div><div class="line">        int newstringLen = oldstringLen + blankNumber * 2; //新字符串的长度</div><div class="line">        <span class="keyword">if</span> (newstringLen&gt;length)</div><div class="line">            return;</div><div class="line">        str[newstringLen] = '\0'; //此行很重要，因为原字符串最后一个字符为'\0'</div><div class="line">		</div><div class="line">        <span class="comment">//设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置</span></div><div class="line">        int point1 = oldstringLen - 1, point2 = newstringLen - 1; //因为'\0'已经手工加到最后新串的最后一个字符，所以减1咯</div><div class="line">		</div><div class="line">        while (point1 &gt;= <span class="number">0</span> &amp;&amp; point2&gt;point1)&#123; </div><div class="line">			<span class="comment">//两指针相同时，跳出循环</span></div><div class="line">            <span class="keyword">if</span> (str[point1] == <span class="string">' '</span>)&#123; </div><div class="line">				<span class="comment">//如果point1指向为空格，那么从point2开始赋值“02%”</span></div><div class="line">                str[point2--] = '0';</div><div class="line">                str[point2--] = '2';</div><div class="line">                str[point2--] = '%';</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">else</span>    </div><div class="line">				<span class="comment">//如果point1指向内容不为空格，那么将内容赋值给point2指向的位置</span></div><div class="line">                str[point2--] = str[point1];</div><div class="line">            point1--; //不管是if还是else都要把point1前移,为了下一次的执行</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 字符串，查找，替换 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[剑指Offer(一)：二维数组的查找]]></title>
      <url>/2017/12/18/%E5%89%91%E6%8C%87Offer-1%EF%BC%9A%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E7%9A%84%E6%9F%A5%E6%89%BE/</url>
      <content type="html"><![CDATA[<p>摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/225H.jpg" alt=""></p>
<h3 id="一、前言"><a href="#一、前言" class="headerlink" title="一、前言"></a><strong>一、前言</strong></h3><p>&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。<br>刷题平台： <a href="https://www.nowcoder.com/practice/abc3fe2ce8e146608e868a70efebf62e?tpId=13&amp;tqId=11154&amp;tPage=1&amp;rp=1&amp;ru=/ta/coding-interviews&amp;qru=/ta/coding-interviews/question-ranking" target="_blank" rel="external">牛客网</a><br><a id="more"></a></p>
<h3 id="二、题目"><a href="#二、题目" class="headerlink" title="二、题目"></a><strong>二、题目</strong></h3><p>&ensp;&ensp; 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p>
<h4 id="1、思路"><a href="#1、思路" class="headerlink" title="1、思路"></a><strong>1、思路</strong></h4><p>&ensp;&ensp;两种思路，一种是：把每一行看成有序递增的数组，利用二分查找，通过遍历每一行找到答案，时间复杂度是nlogn。<br>&ensp;&ensp;另外一种是：每次将二维数组矩阵的中最右上角(或者左下角）的数字与要查找的数字比较，基于二维数组从左到右从上到下递增，那么当最右上角的数字大于目标数字就可以去掉该列，当最右边的数字小于目标数字的时候就去掉该行，如此遍历查找。</p>
<h4 id="2、举例"><a href="#2、举例" class="headerlink" title="2、举例"></a><strong>2、举例</strong></h4><p>&ensp;&ensp; 如果在一个二维数组中找到数字7那么就返回True，否则返回False，这里我们只对第二种方法进行演示。<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/aa.png" alt=""><br>&ensp;&ensp; 查找过程如下：<br><img src="/2017/12/18/剑指Offer-1：二维数组的查找/bb.png" alt=""></p>
<h4 id="3、具体实现"><a href="#3、具体实现" class="headerlink" title="3、具体实现"></a><strong>3、具体实现</strong></h4><p>&ensp;&ensp; C/C++:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line">public class Solution &#123;</div><div class="line">	boolean Find(vector&lt;vector&lt;int&gt; &gt; array, int target) &#123;</div><div class="line">        int rows = array.size();</div><div class="line">        int cols = array[0].size();</div><div class="line">		<span class="keyword">if</span>(!array.empty() &amp;&amp; rows &gt; <span class="number">0</span> &amp;&amp; cols &gt;<span class="number">0</span>)&#123;</div><div class="line">        	int row = 0;</div><div class="line">			int col = cols -1;</div><div class="line">			while(row &lt; rows &amp;&amp; col &gt;= <span class="number">0</span>)&#123;</div><div class="line">            	<span class="keyword">if</span>(target == array[row][col])</div><div class="line">                	return true;</div><div class="line">            	<span class="keyword">else</span> <span class="keyword">if</span>(target&gt;array[row][col])</div><div class="line">                	--col;</div><div class="line">            	<span class="keyword">else</span></div><div class="line">                	++row;</div><div class="line">        	&#125;</div><div class="line">		&#125;</div><div class="line">        return false;</div><div class="line"> </div><div class="line">    &#125;</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 算法基础 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 数组，查找 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[那些让整个人都通透了的回复]]></title>
      <url>/2017/11/30/%E9%82%A3%E4%BA%9B%E8%AE%A9%E6%95%B4%E4%B8%AA%E4%BA%BA%E9%83%BD%E9%80%9A%E9%80%8F%E4%BA%86%E7%9A%84%E5%9B%9E%E5%A4%8D/</url>
      <content type="html"><![CDATA[<p><img src="/2017/11/30/那些让整个人都通透了的回复/about.jpg" alt=""></p>
<p>1、交朋友的标准是什么？<br>答：出世的智者，入世的强者，或者正常而阳光的普通人。</p>
<p>2、男性更看重女性的身材、脸蛋，还是思想？<br>答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。</p>
<p>3、“别让孩子输在起跑线上”有道理吗？<br>答：一辈子都要和别人去比较，是人生悲剧的源头。<br><a id="more"></a></p>
<p>4、做哪些事情可以提升生活品质？<br>答：定期扔东西。</p>
<p>5、结婚以后两个人在一起最重要的是什么？<br>答：就当这婚还没结。</p>
<p>6、怎么反驳“你行你上啊”的逻辑？<br>答：“我评论个电冰箱，自己还得会制冷啊？”</p>
<p>7、把学费拿来念书还是环游世界更合适？为什么？<br>答：读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。</p>
<p>8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？<br>答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨……</p>
<p>9、你心中的完美爱情是怎么样的？<br>答：可以有不完美。</p>
<p>10、异国长期生活，改变了你的哪些“是非观”？<br>答：很多事情只是不同，并无是非。</p>
<p>11、是不是一个人越成熟就越难爱上一个人？<br>答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。</p>
<p>12、如何让这个世界变得美好？<br>答：把你自己变得更美好。</p>
<p>13、苦难有什么价值？<br>答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。</p>
<p>14、如何反驳“现实点，这个社会就是这样”？<br>答：“你是怎样，你的世界就是怎样。”</p>
<p>15、你对自由的理解是什么？<br>答：说“不”的能力。</p>
<p>16、怎么看待励志的书籍？<br>答：看再多，那都是别人的人生。</p>
<p>17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？<br>答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。</p>
<p>18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？<br>答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。</p>
<p>19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？<br>答：说服他人不要诉诸理性，应求于利益。</p>
<p>20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？<br>答：夸奖他人。</p>
<p>21、你是如何走出人生的阴霾的？<br>答：多走几步。</p>
<p>22、二十六岁，工作三年却将留学三年，值得吗？<br>答：普通玩家选择标准配置，高端玩家选择自定义配置。</p>
<p>23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？<br>答：试图用一句话就来总结复杂的人生，是没有希望的。</p>
<p>24、要怎样努力，才能成为很厉害的人？<br>答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。</p>
<p>25、前半生与后半生的分界线是在哪里？<br>答：此时此刻。</p>
<p>26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？<br>答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。</p>
<p>27、人这一生为什么要努力？<br>答：最痛苦的事，不是失败，是我本可以。</p>
<p>28、在一个足够小的星球上行走，我们是在上坡还是下坡？<br>答：你感觉累就是上坡，感觉轻松就是下坡。</p>
<p>29、听过最落寞的一句话或诗句是什么？<br>答：不如意事常八九，可与言者无二三。</p>
<p>30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？<br>答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适</p>
<p>31、三十岁才开始学习编程靠谱吗？<br>答：种一棵树最好的时间是十年前，其次是现在。</p>
<p>32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？<br>答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。</p>
<p>33、省钱的好办法有哪些？<br>答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。</p>
<p>34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？<br>答：知道做不到，等于不知道。</p>
<p>35、什么叫见过大世面？<br>答：能享受最好的，能承受最坏的。</p>
<p>36、科学和迷信的分界点是哪里？<br>答：我错了。</p>
<p>37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？<br>答：保护创意的最好方法，就是将其最好地执行。</p>
<p>38、员工辞职最主要的原因是什么？<br>答：钱少事多离家远，位低权轻责任重。</p>
<p>39、你在生活中得到过的最好的建议是什么？<br>答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。</p>
<p>40、哪些行为是浪费时间？<br>答：思而不学+犹豫不决。</p>
<p>41、最能燃起你学习激情的一句话是什么？<br>答：你不能把这个世界，让给你所鄙视的人。</p>
<p>42、如果好人没好报，我们为什么还要做好人？<br>答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔</p>
<p>43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？<br>答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。</p>
<p>44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？<br>答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台</p>
<p>45、情商不高的例子有哪些？<br>答：对陌生人毕恭毕敬，对亲近的人随意发怒……</p>
<p>46、如何看待“年轻的时候需要的是朋友而不是人脉”？<br>答：没有目的之交往，才能感动人。</p>
<p>47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？<br>答：不要低估你的能力，不要高估你的毅力。</p>
<p>48、有哪些我们熟知的名言其实还有后半句？<br>答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。”</p>
]]></content>
      
        <categories>
            
            <category> 生活随想 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 生活，小情趣，大道理 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[那些年使用Git走过的坑]]></title>
      <url>/2017/11/28/%E9%82%A3%E4%BA%9B%E5%B9%B4%E4%BD%BF%E7%94%A8Git%E8%B5%B0%E8%BF%87%E7%9A%84%E5%9D%91/</url>
      <content type="html"><![CDATA[<p><img src="/2017/11/28/那些年使用Git走过的坑/about1.jpg" alt=""></p>
<h2 id="Git介绍"><a href="#Git介绍" class="headerlink" title="Git介绍"></a>Git介绍</h2><p>&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。<br>&ensp;&ensp;下面就来介绍一下Git的工作流程：</p>
<p>&ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。<br><a id="more"></a></p>
<p>&ensp;&ensp;可以看到，工作流程就是在工作区进行文件的修改，然后使用 git add 实现将修改推送到暂存区，但是这并不会被推送到版本库内。</p>
<p>&ensp;&ensp;最终需要通过 git commit 命令来对之前在暂存区内的更改，提交到版本库，然后就可以进行版本库到远端的传输。</p>
<h2 id="Git的基本操作"><a href="#Git的基本操作" class="headerlink" title="Git的基本操作"></a>Git的基本操作</h2><ol>
<li>如何实现将本地代码部署到GitHub上？</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. Github New Project 【ProjectName】（下称PN）</div><div class="line"><span class="number">2</span>. Copy PN的git地址</div><div class="line"><span class="number">3</span>. 切到本地终端，cd到Project下</div><div class="line"><span class="number">4</span>. git init</div><div class="line"><span class="number">5</span>. git remote add origin 【Copy的url】</div><div class="line"><span class="number">6</span>. git add .</div><div class="line"><span class="number">7</span>. git commit -m <span class="string">"Init Project"</span></div><div class="line"><span class="number">8</span>. git pull —rebase origin master（Github上New Project的时候如果初始化了READ.MD就要走这一步，否则不用；默认不会初始化的）</div><div class="line"><span class="number">9</span>. git push origin master</div></pre></td></tr></table></figure>
<ol>
<li>如何将别人GitHub上的工程下载下来然后自己修改后再上传上去？</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span>. git clone URL 到本地</div><div class="line"><span class="number">2</span>. 修改了本地的<span class="selector-tag">a</span>.py文件</div><div class="line"><span class="number">3</span>. git add .</div><div class="line">4. git commit -m "update a.py"     # 是为了将改动提交到本地git</div><div class="line">5. git pull —rebase origin master   # 是为了拉远端代码到本地</div><div class="line">6. git push origin master               # 是为了推本地代码到远端</div><div class="line">注意第<span class="number">5</span>步，之所以要进行，是因为可能你改动<span class="selector-tag">a</span>.py的同时，我也改动了<span class="selector-tag">a</span>.py，然后我比你先推上去这个时候你如果不pull远端的代码就直接覆盖了。</div></pre></td></tr></table></figure>
<ol>
<li>如何回退到之前的版本，并实现远端和本地的回退？</li>
</ol>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="number">1</span><span class="selector-class">.git</span> status</div><div class="line"><span class="number">2</span>. git pull —rebase origin master</div><div class="line"><span class="number">3</span>. git status</div><div class="line"><span class="number">4</span>. git log   #找出你要回退的commit ID  </div><div class="line"><span class="number">5</span>. <span class="selector-id">#git</span> reset —hard [上一步的commitID]  当然也可以使用 --hard HEAD^ 来逐个查询</div><div class="line"><span class="number">6</span>. git status   #执行完此步后可以看你的文件是不是返回到了修改之前</div><div class="line"><span class="number">7</span>. git push origin master -f     #如果不强推可以实现那就不用加 -f</div></pre></td></tr></table></figure>
<p>更多重要的内容可以参照<a href="https://www.liaoxuefeng.com/wiki/0013739516305929606dd18361248578c67b8067c8c017b000" target="_blank" rel="external">廖雪峰的Git教程</a>，这样将有助于更好的了解Git的相关知识，让你更便捷的管理你的文件。</p>
]]></content>
      
        <categories>
            
            <category> 教程 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Git,Github </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Python中关于str（）函数和repr（）函数的那些事]]></title>
      <url>/2017/11/28/Python%E4%B8%AD%E5%85%B3%E4%BA%8Estr%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E5%92%8Crepr%EF%BC%88%EF%BC%89%E5%87%BD%E6%95%B0%E7%9A%84%E9%82%A3%E4%BA%9B%E4%BA%8B/</url>
      <content type="html"><![CDATA[<p><img src="/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/TheCoast.jpg" alt=""><br>相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。</p>
<p>Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。<br><a id="more"></a></p>
<h3 id="对于字符串：-a-‘hello-world-n’"><a href="#对于字符串：-a-‘hello-world-n’" class="headerlink" title="对于字符串：  a = ‘hello, world!\n’"></a><strong>对于字符串：  a = ‘hello, world!\n’</strong></h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a</div><div class="line">&apos;hello, world!\n&apos;     #输出的a本来的模样</div><div class="line">&gt;&gt;&gt; print(a)          #对a经过加工后输出，将转义字符进行转义</div><div class="line">hello,world!</div><div class="line">&gt;&gt;&gt; print(str(a))     #可以看到对str返回的值进行print处理，这将与直接print（a）得到相同的结果</div><div class="line">hello,world!    </div><div class="line">&gt;&gt;&gt; repr(a)           #获得一种机器阅读的形式，也就是这个变量背地里是什么样子的。</div><div class="line">&quot;&apos;hello, world!\n&apos;&quot;</div><div class="line">&gt;&gt;&gt; print(repr(a))    #对于repr返回的值进行print处理，可以看到这与直接在终端输入a，得到的是相同的结果</div><div class="line">&apos;hello,world!\n&apos;</div></pre></td></tr></table></figure>
<p>以上就是最基本的在字符串的显示中的使用，对应指令和输出结果及注释相信大家很容易都能看明白，接下来说一下这两个函数另外的作用。</p>
<p>###<strong>在类中的使用，可以定义一些在实例运行时，控制repr()函数作用在其实例上时的行为。</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line"></div><div class="line">仅仅是这样的话我们进行如下操作：</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; print(t)</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;</div><div class="line">&gt;&gt;&gt; repr(t)</div><div class="line">&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;</div></pre></td></tr></table></figure>
<p>在类中没有方法的时候，如果直接在终端输入类的实例，不会输出任何东西的，上面显示的内容是由于类的特殊方法（基本定制型）有<strong>str</strong>()和<strong>repr</strong>()， 在print(object)和直接运行实例的时候回打印字符串。如果没有实现（覆盖）该函数，就会出现上面的结果。</p>
<p>那我们定义一个str函数来看看效果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line">     def __str__(self):</div><div class="line">          return &quot;ss&quot;</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;ss&apos;</div><div class="line">&gt;&gt;&gt;print(t)</div><div class="line">ss</div><div class="line">&gt;&gt;&gt;repr(t)</div><div class="line">&lt;__main__.test at 0x4db85f8&gt;</div></pre></td></tr></table></figure>
<p>可以看到在这里直接输入t还会跟上面的例子的结果一致，但是str（t）和print(t)已经发生了改变，不难看出显示的是我们在类中定义的<strong>str</strong>()函数的返回值，而rerp(t)还是 跟上个例子一样，下面我们也来实现一个<strong>str</strong>()函数来看一看效果。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">class test(object):</div><div class="line">     def __init__(self, data):</div><div class="line">          self.data = data</div><div class="line">     def __str__(self):</div><div class="line">          return &quot;ss&quot;</div><div class="line">     def __repr__(self):</div><div class="line">          return &quot;gg&quot;</div><div class="line"></div><div class="line">&gt;&gt;&gt; t = test(100)</div><div class="line">&gt;&gt;&gt; t</div><div class="line">gg</div><div class="line">&gt;&gt;&gt; str(t)</div><div class="line">&apos;ss&apos;</div><div class="line">&gt;&gt;&gt;print(t)</div><div class="line">ss</div><div class="line">&gt;&gt;&gt;repr(t)</div><div class="line">&apos;gg&apos;</div><div class="line">&gt;&gt;&gt; print(repr(t))</div><div class="line">gg</div></pre></td></tr></table></figure>
<p>好了，可以很清楚的明白，默认的<strong>str</strong>() <strong>repr</strong>()函数与重构后的区别，以及这两者与直接输入和经过print处理以后的关系了吧。<br>也就是直接在终端输入对象，相当于调用print（repr(oblect))函数，如果没有被复写则会出现上面最开始的那种显示形式；而print(object)函数相当于调用了print(str(object))这个函数，如果没有被复写就是使用的默认的，也会出现上面的显示结果。</p>
<p>下面还有一个对于<strong>repr</strong>( )函数的说明：<br>Python中这个<em>repr</em>函数，对应repr(object)这个函数，返回一个可以用来表示对象的可打印字符串：</p>
<blockquote>
<p>1.尝试生成这样一个字符串，将其传给 eval()可重新生成同样的对象 ；<br>2.否则，生成用尖括号包住的字符串，包含类型名和额外的信息(比如地址) ；<br>3.一个类(class)可以通过 <strong>repr</strong>() 成员来控制repr()函数作用在其实例上时的行为。</p>
</blockquote>
<p>Python中，有的操作符和函数是做同样的事情，原因是某些场合下函数会比操作符更适合使用，比如函数对象可作为参数传递。</p>
<p>希望我的文章能够帮到你，喜欢的可以点一波关注！！您的支持是博主坚持的动力~~~</p>
]]></content>
      
        <categories>
            
            <category> python学习 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> python,str,repr </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>

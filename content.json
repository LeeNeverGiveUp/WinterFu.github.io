{"meta":{"title":"Zz_krystal的博客","subtitle":"以梦为马不负韶华","description":"NEU小硕一只，攻于机器学习、数据挖掘、深度学习，业余歌手，爱生活，爱音乐！","author":"Winter Fu","url":"http://winterfu.github.io"},"pages":[{"title":"about","date":"2017-11-28T11:18:43.000Z","updated":"2017-11-30T07:23:27.772Z","comments":true,"path":"about/index.html","permalink":"http://winterfu.github.io/about/index.html","excerpt":"","text":"以梦为马，不负韶华。 Winter，勤耕于燕山，研读于沈城热爱音乐与运动，目前是一枚小硕胆小认生，不易相处，年轻无为，卖马为生。 -MoreTheme - NayoGithub - WinterFuAuther - Zz-KrystalLocation - [NEU | ShenYang CN]Email - [fuwinterdong@gmail.com]"},{"title":"tag","date":"2017-11-28T11:18:28.000Z","updated":"2017-11-28T11:28:13.617Z","comments":true,"path":"tags/index.html","permalink":"http://winterfu.github.io/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2017-11-28T11:12:22.000Z","updated":"2017-11-28T11:13:22.716Z","comments":true,"path":"categories/index.html","permalink":"http://winterfu.github.io/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"剑指Offer(四)：树","slug":"剑指Offer-4：树","date":"2017-12-18T09:13:46.000Z","updated":"2017-12-18T09:26:59.204Z","comments":true,"path":"2017/12/18/剑指Offer-4：树/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-4：树/","excerpt":"摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1、思路&ensp;&ensp;这道题首先要明白二叉树的遍历方法，主要分为前序、中序和后序三种遍历方法以及三种遍历的特点，那么就不难解决这个问题了，下面我们来讲一下思路。&ensp;&ensp;先序遍历第一个位置肯定是根节点node， 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组；&ensp;&ensp;另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组，把四个数组找出来，分左右递归调用即可。 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123; int inlen=in.size(); if(inlen==0) return NULL; vector&lt;int&gt; left_pre,right_pre,left_in,right_in; //创建根节点，根节点肯定是前序遍历的第一个数 TreeNode* head=new TreeNode(pre[0]); //找到中序遍历根节点所在位置,存放于变量gen中 int gen=0; for(int i=0;i&lt;inlen;i++) &#123; if (in[i]==pre[0]) &#123; gen=i; break; &#125; &#125; //对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边 //利用上述这点，对二叉树节点进行归并 for(int i=0;i&lt;gen;i++) &#123; left_in.push_back(in[i]); left_pre.push_back(pre[i+1]);//前序第一个为根节点 &#125; for(int i=gen+1;i&lt;inlen;i++) &#123; right_in.push_back(in[i]); right_pre.push_back(pre[i]); &#125; //和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树 //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 head-&gt;left=reConstructBinaryTree(left_pre,left_in); head-&gt;right=reConstructBinaryTree(right_pre,right_in); return head; &#125; &#125;; &ensp;&ensp; 人生苦短，我用Python: 1234567891011121314151617181920# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None elif len(pre) == 1: return TreeNode(pre[0]) else: ans = TreeNode(pre[0]) ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1], tin[:tin.index(pre[0])]) ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:], tin[tin.index(pre[0])+1:]) return ans","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"树,重建","slug":"树-重建","permalink":"http://winterfu.github.io/tags/树-重建/"}]},{"title":"剑指Offer(三)：链表","slug":"剑指Offer-3：链表","date":"2017-12-18T08:57:14.000Z","updated":"2017-12-18T09:12:18.703Z","comments":true,"path":"2017/12/18/剑指Offer-3：链表/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-3：链表/","excerpt":"摘要：输入一个链表，从尾到头打印链表每个节点的值。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：输入一个链表，从尾到头打印链表每个节点的值。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp; 输入一个链表，从尾到头打印链表每个节点的值。 1、思路&ensp;&ensp;这道题目比较简单，但是用普通的循环肯定很难解决，因为链表的存储空间不是紧挨着的，我们可以定义两个向量，从头走到尾分别把每个节点对应的值存下来，求出向量的长度，然后利用循环将上一个向量中的元素逆序存入这个数组，最后返回即可。&ensp;&ensp;还有一种思路就是只使用一个向量，用一下C++高级容器中的反向迭代器 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031# two vectorsclass Solution&#123;public: vector &lt;int&gt; arr1, arr2; while(head != NULL)&#123; //cout&lt;&lt;head-&gt;val&lt;&lt;endl; arr1.push_back(head-&gt;val); head = head-&gt;next; &#125; for(int i = 0; i &lt; arr1.size(); i++)&#123; arr2.push_back(arr1[arr1.size()-1-i]); cout&lt;&lt;arr2[i]&lt;&lt;endl; &#125; return arr2;&#125;;# one vectorclass Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; v; ListNode *p = head; while (p != nullptr) &#123; v.push_back(p-&gt;val); p = p-&gt;next; &#125; //反向迭代器创建临时对象 return vector&lt;int&gt;(v.rbegin(), v.rend()); &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"链表，剑指Offer","slug":"链表，剑指Offer","permalink":"http://winterfu.github.io/tags/链表，剑指Offer/"}]},{"title":"剑指Offer(二）：替换空格","slug":"剑指Offer-2：替换空格","date":"2017-12-18T08:38:29.000Z","updated":"2017-12-18T09:11:40.065Z","comments":true,"path":"2017/12/18/剑指Offer-2：替换空格/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-2：替换空格/","excerpt":"摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台： 牛客网","text":"摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台： 牛客网 二、题目&ensp;&ensp; 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1、思路&ensp;&ensp;最简单的方法就是从头到尾遍历，但是时间复杂度为O（n^2)。&ensp;&ensp;另外一种是：先遍历一次字符串，记录下字符串的长度和空格的数量，这样我们就可以得到新的字符串的总长度了。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\\n”），里面有两个空格，因此替换之后字符串的长度是18。很简单我们直接使用指针去做就好了，还有一点比较重要的就是注意字符串末尾的”\\0”. 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;//length为系统规定字符串输出的最大长度，固定为一个常数class Solution &#123;public: void replaceSpace(char *str, int length)&#123; int blankNumber = 0; //空格的数量 int oldstringLen; //记录原字符串的长度 //首先遍历原字符串，找出字符串的长度以及其中的空格数量 for (oldstringLen = 0; str[oldstringLen] != '\\0'; oldstringLen++)&#123; if (str[oldstringLen] == ' ') blankNumber++; &#125; //根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度 int newstringLen = oldstringLen + blankNumber * 2; //新字符串的长度 if (newstringLen&gt;length) return; str[newstringLen] = '\\0'; //此行很重要，因为原字符串最后一个字符为'\\0' //设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置 int point1 = oldstringLen - 1, point2 = newstringLen - 1; //因为'\\0'已经手工加到最后新串的最后一个字符，所以减1咯 while (point1 &gt;= 0 &amp;&amp; point2&gt;point1)&#123; //两指针相同时，跳出循环 if (str[point1] == ' ')&#123; //如果point1指向为空格，那么从point2开始赋值“02%” str[point2--] = '0'; str[point2--] = '2'; str[point2--] = '%'; &#125; else //如果point1指向内容不为空格，那么将内容赋值给point2指向的位置 str[point2--] = str[point1]; point1--; //不管是if还是else都要把point1前移,为了下一次的执行 &#125; &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"字符串，查找，替换","slug":"字符串，查找，替换","permalink":"http://winterfu.github.io/tags/字符串，查找，替换/"}]},{"title":"剑指Offer(一)：二维数组的查找","slug":"剑指Offer-1：二维数组的查找","date":"2017-12-18T07:53:37.000Z","updated":"2017-12-18T09:11:37.990Z","comments":true,"path":"2017/12/18/剑指Offer-1：二维数组的查找/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-1：二维数组的查找/","excerpt":"摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 一、前言&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。刷题平台： 牛客网","text":"摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 一、前言&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。刷题平台： 牛客网 二、题目&ensp;&ensp; 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1、思路&ensp;&ensp;两种思路，一种是：把每一行看成有序递增的数组，利用二分查找，通过遍历每一行找到答案，时间复杂度是nlogn。&ensp;&ensp;另外一种是：每次将二维数组矩阵的中最右上角(或者左下角）的数字与要查找的数字比较，基于二维数组从左到右从上到下递增，那么当最右上角的数字大于目标数字就可以去掉该列，当最右边的数字小于目标数字的时候就去掉该行，如此遍历查找。 2、举例&ensp;&ensp; 如果在一个二维数组中找到数字7那么就返回True，否则返回False，这里我们只对第二种方法进行演示。&ensp;&ensp; 查找过程如下： 3、具体实现&ensp;&ensp; C/C++: 1234567891011121314151617181920public class Solution &#123; boolean Find(vector&lt;vector&lt;int&gt; &gt; array, int target) &#123; int rows = array.size(); int cols = array[0].size(); if(!array.empty() &amp;&amp; rows &gt; 0 &amp;&amp; cols &gt;0)&#123; int row = 0; int col = cols -1; while(row &lt; rows &amp;&amp; col &gt;= 0)&#123; if(target == array[row][col]) return true; else if(target&gt;array[row][col]) --col; else ++row; &#125; &#125; return false; &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"数组，查找","slug":"数组，查找","permalink":"http://winterfu.github.io/tags/数组，查找/"}]},{"title":"那些让整个人都通透了的回复","slug":"那些让整个人都通透了的回复","date":"2017-11-30T02:54:52.000Z","updated":"2017-11-30T07:32:08.912Z","comments":true,"path":"2017/11/30/那些让整个人都通透了的回复/","link":"","permalink":"http://winterfu.github.io/2017/11/30/那些让整个人都通透了的回复/","excerpt":"1、交朋友的标准是什么？答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？答：一辈子都要和别人去比较，是人生悲剧的源头。","text":"1、交朋友的标准是什么？答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？答：一辈子都要和别人去比较，是人生悲剧的源头。 4、做哪些事情可以提升生活品质？答：定期扔东西。 5、结婚以后两个人在一起最重要的是什么？答：就当这婚还没结。 6、怎么反驳“你行你上啊”的逻辑？答：“我评论个电冰箱，自己还得会制冷啊？” 7、把学费拿来念书还是环游世界更合适？为什么？答：读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。 8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨…… 9、你心中的完美爱情是怎么样的？答：可以有不完美。 10、异国长期生活，改变了你的哪些“是非观”？答：很多事情只是不同，并无是非。 11、是不是一个人越成熟就越难爱上一个人？答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。 12、如何让这个世界变得美好？答：把你自己变得更美好。 13、苦难有什么价值？答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 14、如何反驳“现实点，这个社会就是这样”？答：“你是怎样，你的世界就是怎样。” 15、你对自由的理解是什么？答：说“不”的能力。 16、怎么看待励志的书籍？答：看再多，那都是别人的人生。 17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。 19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？答：说服他人不要诉诸理性，应求于利益。 20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？答：夸奖他人。 21、你是如何走出人生的阴霾的？答：多走几步。 22、二十六岁，工作三年却将留学三年，值得吗？答：普通玩家选择标准配置，高端玩家选择自定义配置。 23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？答：试图用一句话就来总结复杂的人生，是没有希望的。 24、要怎样努力，才能成为很厉害的人？答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。 25、前半生与后半生的分界线是在哪里？答：此时此刻。 26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。 27、人这一生为什么要努力？答：最痛苦的事，不是失败，是我本可以。 28、在一个足够小的星球上行走，我们是在上坡还是下坡？答：你感觉累就是上坡，感觉轻松就是下坡。 29、听过最落寞的一句话或诗句是什么？答：不如意事常八九，可与言者无二三。 30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适 31、三十岁才开始学习编程靠谱吗？答：种一棵树最好的时间是十年前，其次是现在。 32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 33、省钱的好办法有哪些？答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。 34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？答：知道做不到，等于不知道。 35、什么叫见过大世面？答：能享受最好的，能承受最坏的。 36、科学和迷信的分界点是哪里？答：我错了。 37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？答：保护创意的最好方法，就是将其最好地执行。 38、员工辞职最主要的原因是什么？答：钱少事多离家远，位低权轻责任重。 39、你在生活中得到过的最好的建议是什么？答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。 40、哪些行为是浪费时间？答：思而不学+犹豫不决。 41、最能燃起你学习激情的一句话是什么？答：你不能把这个世界，让给你所鄙视的人。 42、如果好人没好报，我们为什么还要做好人？答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔 43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台 45、情商不高的例子有哪些？答：对陌生人毕恭毕敬，对亲近的人随意发怒…… 46、如何看待“年轻的时候需要的是朋友而不是人脉”？答：没有目的之交往，才能感动人。 47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？答：不要低估你的能力，不要高估你的毅力。 48、有哪些我们熟知的名言其实还有后半句？答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。”","categories":[{"name":"生活随想","slug":"生活随想","permalink":"http://winterfu.github.io/categories/生活随想/"}],"tags":[{"name":"生活，小情趣，大道理","slug":"生活，小情趣，大道理","permalink":"http://winterfu.github.io/tags/生活，小情趣，大道理/"}]},{"title":"那些年使用Git走过的坑","slug":"那些年使用Git走过的坑","date":"2017-11-28T13:43:31.000Z","updated":"2017-11-30T07:32:45.798Z","comments":true,"path":"2017/11/28/那些年使用Git走过的坑/","link":"","permalink":"http://winterfu.github.io/2017/11/28/那些年使用Git走过的坑/","excerpt":"Git介绍&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。&ensp;&ensp;下面就来介绍一下Git的工作流程： &ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。","text":"Git介绍&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。&ensp;&ensp;下面就来介绍一下Git的工作流程： &ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。 &ensp;&ensp;可以看到，工作流程就是在工作区进行文件的修改，然后使用 git add 实现将修改推送到暂存区，但是这并不会被推送到版本库内。 &ensp;&ensp;最终需要通过 git commit 命令来对之前在暂存区内的更改，提交到版本库，然后就可以进行版本库到远端的传输。 Git的基本操作 如何实现将本地代码部署到GitHub上？ 1234567891. Github New Project 【ProjectName】（下称PN）2. Copy PN的git地址3. 切到本地终端，cd到Project下4. git init5. git remote add origin 【Copy的url】6. git add .7. git commit -m \"Init Project\"8. git pull —rebase origin master（Github上New Project的时候如果初始化了READ.MD就要走这一步，否则不用；默认不会初始化的）9. git push origin master 如何将别人GitHub上的工程下载下来然后自己修改后再上传上去？ 12345671. git clone URL 到本地2. 修改了本地的a.py文件3. git add .4. git commit -m \"update a.py\" # 是为了将改动提交到本地git5. git pull —rebase origin master # 是为了拉远端代码到本地6. git push origin master # 是为了推本地代码到远端注意第5步，之所以要进行，是因为可能你改动a.py的同时，我也改动了a.py，然后我比你先推上去这个时候你如果不pull远端的代码就直接覆盖了。 如何回退到之前的版本，并实现远端和本地的回退？ 12345671.git status2. git pull —rebase origin master3. git status4. git log #找出你要回退的commit ID 5. #git reset —hard [上一步的commitID] 当然也可以使用 --hard HEAD^ 来逐个查询6. git status #执行完此步后可以看你的文件是不是返回到了修改之前7. git push origin master -f #如果不强推可以实现那就不用加 -f 更多重要的内容可以参照廖雪峰的Git教程，这样将有助于更好的了解Git的相关知识，让你更便捷的管理你的文件。","categories":[{"name":"教程","slug":"教程","permalink":"http://winterfu.github.io/categories/教程/"}],"tags":[{"name":"Git,Github","slug":"Git-Github","permalink":"http://winterfu.github.io/tags/Git-Github/"}]},{"title":"Python中关于str（）函数和repr（）函数的那些事","slug":"Python中关于str（）函数和repr（）函数的那些事","date":"2017-11-28T13:34:40.000Z","updated":"2017-11-30T07:37:21.073Z","comments":true,"path":"2017/11/28/Python中关于str（）函数和repr（）函数的那些事/","link":"","permalink":"http://winterfu.github.io/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/","excerpt":"相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。 Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。","text":"相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。 Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。 对于字符串： a = ‘hello, world!\\n’12345678910&gt;&gt;&gt; a&apos;hello, world!\\n&apos; #输出的a本来的模样&gt;&gt;&gt; print(a) #对a经过加工后输出，将转义字符进行转义hello,world!&gt;&gt;&gt; print(str(a)) #可以看到对str返回的值进行print处理，这将与直接print（a）得到相同的结果hello,world! &gt;&gt;&gt; repr(a) #获得一种机器阅读的形式，也就是这个变量背地里是什么样子的。&quot;&apos;hello, world!\\n&apos;&quot;&gt;&gt;&gt; print(repr(a)) #对于repr返回的值进行print处理，可以看到这与直接在终端输入a，得到的是相同的结果&apos;hello,world!\\n&apos; 以上就是最基本的在字符串的显示中的使用，对应指令和输出结果及注释相信大家很容易都能看明白，接下来说一下这两个函数另外的作用。 ###在类中的使用，可以定义一些在实例运行时，控制repr()函数作用在其实例上时的行为。 123456789101112131415class test(object): def __init__(self, data): self.data = data仅仅是这样的话我们进行如下操作：&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; t&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; print(t)&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; str(t)&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;&gt;&gt;&gt; repr(t)&apos;&lt;__main__.test at 0x4db85f8&gt;&apos; 在类中没有方法的时候，如果直接在终端输入类的实例，不会输出任何东西的，上面显示的内容是由于类的特殊方法（基本定制型）有str()和repr()， 在print(object)和直接运行实例的时候回打印字符串。如果没有实现（覆盖）该函数，就会出现上面的结果。 那我们定义一个str函数来看看效果： 123456789101112131415class test(object): def __init__(self, data): self.data = data def __str__(self): return &quot;ss&quot;&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; t&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; str(t)&apos;ss&apos;&gt;&gt;&gt;print(t)ss&gt;&gt;&gt;repr(t)&lt;__main__.test at 0x4db85f8&gt; 可以看到在这里直接输入t还会跟上面的例子的结果一致，但是str（t）和print(t)已经发生了改变，不难看出显示的是我们在类中定义的str()函数的返回值，而rerp(t)还是 跟上个例子一样，下面我们也来实现一个str()函数来看一看效果。 1234567891011121314151617181920class test(object): def __init__(self, data): self.data = data def __str__(self): return &quot;ss&quot; def __repr__(self): return &quot;gg&quot;&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; tgg&gt;&gt;&gt; str(t)&apos;ss&apos;&gt;&gt;&gt;print(t)ss&gt;&gt;&gt;repr(t)&apos;gg&apos;&gt;&gt;&gt; print(repr(t))gg 好了，可以很清楚的明白，默认的str() repr()函数与重构后的区别，以及这两者与直接输入和经过print处理以后的关系了吧。也就是直接在终端输入对象，相当于调用print（repr(oblect))函数，如果没有被复写则会出现上面最开始的那种显示形式；而print(object)函数相当于调用了print(str(object))这个函数，如果没有被复写就是使用的默认的，也会出现上面的显示结果。 下面还有一个对于repr( )函数的说明：Python中这个repr函数，对应repr(object)这个函数，返回一个可以用来表示对象的可打印字符串： 1.尝试生成这样一个字符串，将其传给 eval()可重新生成同样的对象 ；2.否则，生成用尖括号包住的字符串，包含类型名和额外的信息(比如地址) ；3.一个类(class)可以通过 repr() 成员来控制repr()函数作用在其实例上时的行为。 Python中，有的操作符和函数是做同样的事情，原因是某些场合下函数会比操作符更适合使用，比如函数对象可作为参数传递。 希望我的文章能够帮到你，喜欢的可以点一波关注！！您的支持是博主坚持的动力~~~","categories":[{"name":"python学习","slug":"python学习","permalink":"http://winterfu.github.io/categories/python学习/"}],"tags":[{"name":"python,str,repr","slug":"python-str-repr","permalink":"http://winterfu.github.io/tags/python-str-repr/"}]}]}
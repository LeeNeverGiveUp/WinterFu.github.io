{"meta":{"title":"Zz_krystal的博客","subtitle":"以梦为马不负韶华","description":"NEU小硕一只，攻于机器学习、数据挖掘、深度学习，业余歌手，爱生活，爱音乐！","author":"Winter Fu","url":"http://winterfu.github.io"},"pages":[{"title":"categories","date":"2017-11-28T11:12:22.000Z","updated":"2017-11-28T11:13:22.716Z","comments":true,"path":"categories/index.html","permalink":"http://winterfu.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2017-11-28T11:18:43.000Z","updated":"2017-11-30T07:23:27.772Z","comments":true,"path":"about/index.html","permalink":"http://winterfu.github.io/about/index.html","excerpt":"","text":"以梦为马，不负韶华。 Winter，勤耕于燕山，研读于沈城热爱音乐与运动，目前是一枚小硕胆小认生，不易相处，年轻无为，卖马为生。 -MoreTheme - NayoGithub - WinterFuAuther - Zz-KrystalLocation - [NEU | ShenYang CN]Email - [fuwinterdong@gmail.com]"},{"title":"tag","date":"2017-11-28T11:18:28.000Z","updated":"2017-11-28T11:28:13.617Z","comments":true,"path":"tags/index.html","permalink":"http://winterfu.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"排序（六）：堆排序","slug":"排序6：堆排序","date":"2018-01-12T07:40:46.000Z","updated":"2018-01-12T11:10:12.867Z","comments":true,"path":"2018/01/12/排序6：堆排序/","link":"","permalink":"http://winterfu.github.io/2018/01/12/排序6：堆排序/","excerpt":"摘要：堆排序（Heap Sort)是一种利用堆的性质进行的一种选择排序算法。 一、前言&ensp;&ensp;在介绍堆排序之前，需要先说明一下什么是“堆”？堆又被称为优先队列（priority queue），尽管名为优先队列，但是堆不是队列。在队列中我们经常做的操作就是入队和出队，其中出队是按照进入队列的顺序来取元素的，而在堆中我们是按照元素的优先级取出元素的。","text":"摘要：堆排序（Heap Sort)是一种利用堆的性质进行的一种选择排序算法。 一、前言&ensp;&ensp;在介绍堆排序之前，需要先说明一下什么是“堆”？堆又被称为优先队列（priority queue），尽管名为优先队列，但是堆不是队列。在队列中我们经常做的操作就是入队和出队，其中出队是按照进入队列的顺序来取元素的，而在堆中我们是按照元素的优先级取出元素的。&ensp;&ensp;这里的优先级就好像我们候机的时候，无论谁先到达候机大厅，总是头等舱的乘客先登机，然后是商务舱乘客，最后才是经济舱。每个乘客的机票对应头等舱、商务舱、经济舱三种键值中的一个。头等舱–&gt;商务舱–&gt;经济舱依次享有从高到低的优先级，这也就是堆取元素的规则。&ensp;&ensp;堆的一个经典实现是完全二叉树（complete binary tree）,这样实现的堆称为二叉堆，也就是很多数据结构书中的堆啦。&ensp;&ensp;前面提到二叉堆是完全二叉树或者近似完全二叉树，那么二叉堆又有哪些性质呢？ 1.任一节点的键值总是大于或者等于（小于或者等于）左右子树节点的键值，前者称为最大堆如下图左，后者称为最小堆如下图右。 每一个节点的左子树和有字数都是一个二叉堆&ensp;&ensp;堆的存储方式：一般用“数组”来表示堆，父节点和子节点的位置存在一定的关系。&ensp;&ensp;对于父节点和子节点的位置有如下关系（这是建立数组下标从0开始的情况，若数组下标从一开始，则左右孩子的下标还需要多减掉一个1）： 索引为i的节点的左孩子的索引是（2*i+1） 索引为i的节点的右孩子的索引是（2*i+2) 索引为i的节点的父节点的索引是 floor((i - 1) / 2) 二、算法思想&ensp;&ensp;上面已经介绍了堆的概念和性质，那么对于一个无序数组如何利用堆的性质对其进行排序呢？主要步骤可以描述为两个过程： 根据初始数组去构造初始堆（构建一个完全二叉树，保证所有的父节点对应的键值都比其左右孩子节点对应的键值大）。 每次交换第一个和最后一个元素，输出最后一个元素（最大值），然后把剩下的元素重新调整为最大堆。 1、算法图解&ensp;&ensp;以数列{16, 7, 3, 20, 17, 8}为例，我们先来构造初始堆，需要先构建完全二叉树（并不是真的写代码构建，只是把数组看成完全二叉树去操作），然后调整调换节点使其满足最大堆的要求。&ensp;&ensp;根据上面的数组元素构建一个完全二叉树，得到&ensp;&ensp;然后需要调整节点，构造初始堆，则从最后一个非叶节点开始调整，调整过程如下： 程序从最后一个非叶节点即节点3开始。判断其又孩子：8 &gt; 3，则把8调整上去。 节点3下无孩子，判断结束。继续往前判断非叶节点即节点7，判断其左右孩子：20和17，20最大故将其调整上去。 节点7下无孩子，判断结束。继续往前一步，到达节点16，判断其左右孩子：20和8，其中20最大，将其调整上去。 判断节点16下左右孩子：7和17，17最大将其调整上去。 节点16下无孩子，判断结束。遍历已至头部，整个过程结束，得到最大堆。 &ensp;&ensp;上面我们已经将无需数组变最大堆了，那么接下来的操作就很简单了：&ensp;&ensp;上面提到需要从最后一个非叶节点开始，那么如何确定最后一个非叶节点呢？ 其实这是有公式的，设二叉树的总结点数为n，则最后一个非叶节点是第[n / 2]个节点。 2、具体实现&ensp;&ensp; 根据上面的算法流程，不难实现堆排序算法，首先我们用C/C++实现（注意这里我们使用数组是从索引0开始的）: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;void HeapAdjust(vector&lt;int&gt; &amp;list, int parent, int length)&#123; int temp = list[parent]; // temp保存当前父节点 int child = 2 * parent + 1; // 先获得左孩子 while (child &lt; length)&#123; // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点 if (child + 1 &lt; length &amp;&amp; list[child] &lt; list[child + 1])&#123; child++; &#125; // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点 if (temp &gt;= list[child])&#123; break; &#125; // 把孩子结点的值赋给父结点 list[parent] = list[child]; // 选取孩子结点的左孩子结点,继续向下筛选 parent = child; child = 2 * parent + 1; &#125; list[parent] = temp;&#125;vector&lt;int&gt; HeadSort(vector&lt;int&gt; list)&#123; int length = list.size(); // 循环建立初始堆 for (int i = length / 2; i &gt;= 0; i--)&#123; HeapAdjust(list, i, length); &#125; // 进行n-1次循环，完成排序 for (int i = length - 1; i &gt; 0; i--)&#123; // 最后一个元素和第一元素进行交换 int temp = list[i]; list[i] = list[0]; list[0] = temp; // 筛选 R[0] 结点，得到i-1个结点的堆 HeapAdjust(list, 0, i); &#125; return list;&#125; 三、时间空间复杂度及算法稳定性分析&ensp;&ensp;时间复杂度的计算主要分为两部分，第一部分：首先计算堆的时间，n个节点，从第0层至第logn层，对于第i层的第2i个节点如果往下走logn - 1步，那么走完所有的步时间为O（n）;第二部分是排序的时间：HeapAdjust() 耗时 logn，共 n 次，故排序时间为 O(nlogn)。 &ensp;&ensp;堆的存储表示是顺序的。因为堆所对应的二叉树为完全二叉树，而完全二叉树通常采用顺序存储方式。当想得到一个序列中第k个最小的元素之前的部分排序序列，最好采用堆排序。 &ensp;&ensp;堆排序是一种不稳定算法。因为在堆的调整过程中，关键字进行比较和交换所走的是该结点到叶子结点的一条路径，因此对于相同的关键字就可能出现排在后面的关键字被交换到前面来的情况。 参考资料&ensp;&ensp;https://61mon.com/index.php/archives/202/&ensp;&ensp;https://mp.weixin.qq.com/s/HIspLRoS6vWtxMQ0TJhQpA","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,堆,完全二叉树","slug":"排序-堆-完全二叉树","permalink":"http://winterfu.github.io/tags/排序-堆-完全二叉树/"}]},{"title":"排序（五）：shell排序","slug":"排序5：shell排序","date":"2018-01-12T01:45:16.000Z","updated":"2018-01-12T03:22:55.468Z","comments":true,"path":"2018/01/12/排序5：shell排序/","link":"","permalink":"http://winterfu.github.io/2018/01/12/排序5：shell排序/","excerpt":"摘要：希尔排序（Shell Sort)也称递减量排序算法，以其设计者希尔(Donald Shell)的名字命名，该算法由1959年公布。 一、前言&ensp;&ensp;shell排序是一种插入排序，它是直接插入排序算法的一种威力加强版。","text":"摘要：希尔排序（Shell Sort)也称递减量排序算法，以其设计者希尔(Donald Shell)的名字命名，该算法由1959年公布。 一、前言&ensp;&ensp;shell排序是一种插入排序，它是直接插入排序算法的一种威力加强版。 二、算法思想&ensp;&ensp;该算法的基本思想是：将待排元素序列切割成若干个子序列（由相隔某个“增量”（gap）的元素组成），然后对这些子序列分别进行直接插入排序，然后按照规则一次缩减增量再进行排序，待整个序列中的元素基本有序（gap足够小）时，再对全体元素进行一次直接插入排序，即可完成所有排序工作。 1、算法图解&ensp;&ensp;以n=10的一个数列{49, 38, 65, 97, 26, 13, 27, 49, 55, 4}为例，演示其选择排序过程，示意图如下：&ensp;&ensp;第一次的gap我们选择数组长度的一半：gap = 10 / 2 = 5 &ensp;&ensp;其中，1A,1B，2A,2B等为分组标记，数字同样的表示在同一组，大写字母表示是该组的第几个元素， 每次对同一组的数据进行直接插入排序。即分成了五组(49, 13) (38, 27) (65, 49) (97, 55) (26, 4)这样每组排序后就变成了(13, 49) (27, 38) (49, 65) (55, 97) (4, 26)，下同。 排序后的数组变成：{13, 27, 49, 55, 4, 49, 38, 65, 97, 26}&ensp;&ensp;第二次gap = 5 / 2 = 2&ensp;&ensp;第三次gap = 2 / 2 = 1&ensp;&ensp;第四次gap = 1 / 2 = 0 排序完毕得到有序数组&ensp;&ensp;注意：每个小分组的元素进行直接插入排序后，直接映射到原数组，发生交换就互换，否则还 保持原来的顺序。可以看到图中有两个相等数值的元素“5”，通过排序过程我们可以看到，这两个元素位置交换了，所以希尔排序是不稳定算法。 2、具体实现&ensp;&ensp; 根据上面的思路，不难写出shell排序的实现，首先我们用C/C++实现: 12345678910111213141516171819void ShellSort(int array[], int n)&#123; for (int gap = n &gt;&gt; 1; gap &gt; 0; gap &gt;&gt;= 1) &#123; for (int i = gap; i &lt; n; i++) &#123; int temp = array[i]; int j = i - gap; while (j &gt;= 0 &amp;&amp; array[j] &gt; temp) &#123; array[j + gap] = array[j]; j -= gap; &#125; array[j + gap] = temp; &#125; &#125;&#125; &ensp;&ensp;人生苦短，我用Python: 123456789101112131415161718# -*- coding:utf-8 -*-def ShellSort(input_list): if len(input_list) == 0: return [] result = input_list n = len(result) gap = n // 2 while gap &gt; 0: gap //= 2 for i in range(gap, len(result)): temp = result[i] j = i - gap while j &gt;= 0 and temp &lt; result[j]: result[j + gap] = result[j] j -= gap result[j + gap] = temp return result 三、时间空间复杂度及算法稳定性分析&ensp;&ensp;可想而知，步长的选择是希尔排序的重要部分。算法最开始以一定的步长进行排序，然后会继续以更小的步长进行排序，最终算法以步长为 1 进行排序。当步长为 1 时，算法变为直接插入排序，这就保证了数据一定会被全部排序。&ensp;&ensp;Donald Shell 最初建议步长选择为 n / 2，并且对步长取半直到步长达到 1。虽然这样取可以比 O(n^2) 类的算法（直接插入排序）更好，但这样仍然有减少平均时间和最差时间的余地。可能希尔排序最重要的地方在于当用较小步长排序后，以前用的较大步长仍然是有序的。比如，如果一个数列以步长 5 进行了排序然后再以步长 3 进行排序，那么该数列不仅是以步长 3 有序，而且是以步长 5 有序。如果不是这样，那么算法在迭代过程中会打乱以前的顺序，那就不会以如此短的时间完成排序了。&ensp;&ensp;比较在希尔排序中是最主要的操作，而不是交换。用这样步长序列的希尔排序比插入排序要快，甚至在小数组中比快速排序和堆排序还快，但是在涉及大量数据时希尔排序还是比快速排序慢。 &ensp;&ensp;算法稳定性我们已经在上面的算法图解中提到过，shell排序是一种不稳定算法。 &ensp;&ensp;直接插入排序和shell排序的比较： 直接插入排序是稳定的；而希尔排序是不稳定的。 直接插入排序更适合于原始记录基本有序的集合。 希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。 希尔排序的比较次数和移动次数都要比直接插入排序少，当N越大时，效果越明显。 直接插入排序也适用于链式存储结构；希尔排序不适用于链式结构。 附注：上面希尔排序的步长选择都是从n/2開始，每次再减半，直在结束时1。事实上，它可能有另一个更有效的步骤选择，假定读者兴趣了解。看到壳牌排序步骤的描述维基百科：http://zh.wikipedia.org/wiki/%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F 参考资料&ensp;&ensp;https://www.cnblogs.com/gcczhongduan/p/4593943.html&ensp;&ensp;https://www.61mon.com/index.php/archives/193/&ensp;&ensp;http://cuijiahua.com/blog/2017/12/algorithm_3.html","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,shell","slug":"排序-shell","permalink":"http://winterfu.github.io/tags/排序-shell/"}]},{"title":"字符串模式匹配","slug":"字符串匹配","date":"2018-01-11T01:41:24.000Z","updated":"2018-01-12T03:16:57.697Z","comments":true,"path":"2018/01/11/字符串匹配/","link":"","permalink":"http://winterfu.github.io/2018/01/11/字符串匹配/","excerpt":"摘要：字符串和数组是两种最基本的数据结构，都是用连续内存分别存储字符和数字，数组常用来查找，字符串常见的问题以字符串匹配最为常见。 一、前言&ensp;&ensp; 字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，那我们想知道，里面是否包含另一个字符串”ABCDABD”？ &ensp;&ensp;其中，前者叫作目标串称作T，也就是待查找的字符串，后者称为模式串称作P，如果T中存在一个或多个模式为P的子串，就给出该串在T中的位置，称为匹配成功；否则匹配失败。","text":"摘要：字符串和数组是两种最基本的数据结构，都是用连续内存分别存储字符和数字，数组常用来查找，字符串常见的问题以字符串匹配最为常见。 一、前言&ensp;&ensp; 字符串匹配是计算机的基本任务之一。举例来说，有一个字符串”BBC ABCDAB ABCDABCDABDE”，那我们想知道，里面是否包含另一个字符串”ABCDABD”？ &ensp;&ensp;其中，前者叫作目标串称作T，也就是待查找的字符串，后者称为模式串称作P，如果T中存在一个或多个模式为P的子串，就给出该串在T中的位置，称为匹配成功；否则匹配失败。 二、算法详解&ensp;&ensp;关于字符串匹配的算法也有很多，接下来我们来依次介绍。蛮力算法（BF算法） 1、算法介绍&ensp;&ensp;蛮力算法（Brute-Force)，简称BF算法，其核心思想是：从目标串T的第一个字符与模式串P的第一个字符开始比较，若相等，则继续对字符串进行后续的比较；否则目标串从第二个字符起与模式串的第一个字符重新比较。直至模式串中的每个字符一次和目标串中的一个连续字符序列相等为止，此时称为匹配成功，否则匹配失败。 2、算法图解&ensp;&ensp;接下来我们将以图解的形式来说明这种算法： 3、性能分析 假设模式串的长度是m，目标串的长度是n。 最坏的情况是每遍比较都在最后出现不等，即没变最多比较m次，最多比较n-m+1遍。 总的比较次数最多为m(n-m+1)，因此BF算法的时间复杂度为O(mn)。 BF算法中存在回溯，这影响到效率，因而在实际应用中很少采用。 4、具体实现123456789101112131415161718192021222324252627282930313233343536#include &lt;iostream&gt;#include &lt;string&gt;using namespace stdint bfMatch(string target, string pattern) &#123; int pos = -1; int i = 0, j = 0, k = 0; // 在没找到匹配pattern的子串前，遍历整个target while (-1 == pos &amp;&amp; i &lt; (int)target.length()) &#123; // 将目标串和模式串逐一比对，如果有不同的则退出 while (j &lt; (int)pattern.length() &amp;&amp; target[i] == pattern[j]) &#123; i++; j++; &#125; if (j &gt;= (int)pattern.length()) &#123; // 如果模式串扫描完，说明目标串中含有这个子串 pos = k; &#125; else &#123; // 反之，没有扫描完，则从目标串的下一个字符开始重新逐一比对 j = 0; k++; i = k; &#125; &#125; return pos;&#125;void print(string target, string pattern, int index) &#123; if (-1 != index) &#123; cout &lt;&lt; \"[\" &lt;&lt; pattern &lt;&lt; \"] is in the Pos = \" &lt;&lt; index &lt;&lt; \" of [\" &lt;&lt; target &lt;&lt; \"]\" &lt;&lt; endl; &#125; else &#123; cout &lt;&lt; \"[\" &lt;&lt; pattern &lt;&lt; \"] is not in the [\" &lt;&lt; target &lt;&lt; \"]\" &lt;&lt; endl; &#125;&#125; KMP算法&ensp;&ensp;KMP算法全称是Knuth-Morris-Pratt算法，其命名规则是按照三个发明人的名字命名的，开头的那个K，没错！就是那个老头，著名的科学家Donald Knuth。&ensp;&ensp;这种算法不太容易理解，相信很多同学看这个算法的时候都是一头雾水，什么“部分匹配”，“移位”什么的都是怎么计算移动的，没关系，接下来我们就通俗的讲解一下这个算法。 1、部分匹配表&ensp;&ensp;我们首先来介绍一个概念“部分匹配表”，顾名思义就是部分上能够匹配上的字符记录表格。那么这个表示怎么产生的呢？那我们就要理解一下什么是“前缀”和“后缀”的概念。”前缀”指除了最后一个字符以外，一个字符串的全部头部组合；”后缀”指除了第一个字符以外，一个字符串的全部尾部组合。&ensp;&ensp;”部分匹配值”就是”前缀”和”后缀”的最长的共有元素的长度。以”ABCDABD”为例：&ensp;&ensp;”部分匹配”的实质是，有时候，字符串头部和尾部会有重复。比如，”ABCDAB”之中有两个”AB”，那么它的”部分匹配值”就是2（”AB”的长度）。搜索词移动的时候，第一个”AB”向后移动4位（字符串长度-部分匹配值），就可以来到第二个”AB”的位置。 2、实例详解&ensp;&ensp;我们要在字符串“BBC ABCDAB ABCDABCDABDE”中判断是否包含字符串“ABCDABD”。我们将ABCDABD称之为搜索词。&ensp;&ensp;第一步：字符串”BBC ABCDAB ABCDABCDABDE”的第一个字符与搜索词”ABCDABD”的第一个字符，进行比较。因为B与A不匹配，所以搜索词后移一位。&ensp;&ensp;第二步：因为B与A不匹配，搜索词再往后移。就这样，直到字符串有一个字符，与搜索词的第一个字符相同为止。&ensp;&ensp;第三步：接着比较字符串和搜索词的下一个字符，还是相同。&ensp;&ensp;第四步：接着往下比较，直到字符串有一个字符，与搜索词对应的字符不相同为止。&ensp;&ensp;第五步：这时，最自然的反应是，将搜索词整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把”搜索位置”移到已经比较过的位置，重比一遍。&ensp;&ensp;第六步：一个基本事实是，当空格与D不匹配时，你其实知道前面六个字符是”ABCDAB”。KMP算法的想法是，设法利用这个已知信息，不要把”搜索位置”移回已经比较过的位置，继续把它向后移，这样就提高了效率。&ensp;&ensp;第七步：怎么做到这一点呢？可以针对搜索词，算出一张《部分匹配表》（Partial Match Table）。这张表是如何产生的，后面再介绍，这里只要会用就可以了。&ensp;&ensp;第八步：已知空格与D不匹配时，前面六个字符”ABCDAB”是匹配的。查表可知，最后一个匹配字符B对应的”部分匹配值”为2，因此按照下面的公式算出向后移动的位数： 移动位数 = 已匹配的字符数 - 对应的部分匹配值计算可以得出搜索词应该向后移动6 - 2 = 4位。&ensp;&ensp;第九步：因为空格与Ｃ不匹配，搜索词还要继续往后移。这时，已匹配的字符数为2（”AB”），对应的”部分匹配值”为0。所以，移动位数 = 2 - 0，结果为 2，于是将搜索词向后移2位。&ensp;&ensp;第十步：因为空格与A不匹配，继续后移一位。&ensp;&ensp;第十一步：逐位比较，直到发现C与D不匹配。于是，移动位数 = 6 - 2，继续将搜索词向后移动4位。&ensp;&ensp;逐位比较，直到搜索词的最后一位，发现完全匹配，于是搜索完成。如果还要继续搜索（即找出全部匹配），移动位数 = 7 - 0，再将搜索词向后移动7位，这里就不再重复了。 3、性能分析 假设模式串的长度是m，目标串的长度是n。 在KMP算法中求next数组的时间复杂度为O(m)，在后面的匹配中因目标串T的下标不用回溯，所以比较次数可记为n。 由此，得出KMP算法的总的时间复杂度为O(n+m)。 4、具体实现 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;iostream&gt;#include &lt;string&gt;using namespace std;const int MAX = 100;int next[MAX] = &#123;0&#125;;// 计算部分匹配表void getNext(string pattern) &#123; int j = 0, k = -1; next[0] = -1; while (j &lt; (int)pattern.length() - 1) &#123; if (-1 == k || pattern[j] == pattern[k]) &#123; j++; k++; next[j] = k; &#125; else &#123; k = next[k]; &#125; &#125; return;&#125;// KMP算法int kmpMatch(string target, string pattern) &#123; int i = 0, j = 0, index = 0; getNext(pattern); // 计算部分匹配表 while (i &lt; (int)target.length() &amp;&amp; j &lt; (int)pattern.length()) &#123; if (-1 == j || target[i] == pattern[j]) &#123; i++; j++; &#125; else &#123; j = next[j]; // 如果出现部分不匹配，获取跳过的位置 &#125; &#125; if (j &gt;= (int)pattern.length()) index = i - pattern.length(); // 匹配成功，返回匹配子串的首字符下标 else index = -1; // 匹配失败 return index;&#125; 参考资料&ensp;&ensp;http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html&ensp;&ensp;http://www.cnblogs.com/jingmoxukong/p/4343770.html","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"字符串,查找,匹配","slug":"字符串-查找-匹配","permalink":"http://winterfu.github.io/tags/字符串-查找-匹配/"}]},{"title":"剑指offer（八）：斐波那契数列的拓展","slug":"剑指offer-8：斐波那契数列的拓展","date":"2018-01-10T08:03:03.000Z","updated":"2018-01-10T11:14:01.701Z","comments":true,"path":"2018/01/10/剑指offer-8：斐波那契数列的拓展/","link":"","permalink":"http://winterfu.github.io/2018/01/10/剑指offer-8：斐波那契数列的拓展/","excerpt":"摘要：前面我们已经提到很多问题都可看作是斐波那契数列的应用，这也是面试官经常考察的，如何将一个问题抽象成已有知识可以解答的问题的能力。 一、前言&ensp;&ensp; 不少面试题都可以看成是斐波那契数列的应用，下面我们就来介绍一个实际的应用和解题思路。刷题平台： 牛客网-跳台阶，牛客网-变态跳台阶，牛客网-矩形覆盖","text":"摘要：前面我们已经提到很多问题都可看作是斐波那契数列的应用，这也是面试官经常考察的，如何将一个问题抽象成已有知识可以解答的问题的能力。 一、前言&ensp;&ensp; 不少面试题都可以看成是斐波那契数列的应用，下面我们就来介绍一个实际的应用和解题思路。刷题平台： 牛客网-跳台阶，牛客网-变态跳台阶，牛客网-矩形覆盖 二、题目 一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 一只青蛙一次可以跳上1级台阶，也可以跳上2级……它也可以跳上n级。求该青蛙跳上一个n级的台阶总共有多少种跳法。 我们可以用2x1的小矩形横着或者竖着去覆盖更大的矩形。请问用n个2x1的小矩形无重叠地覆盖一个2xn的大矩形，总共有多少种方法？ 1、思路&ensp;&ensp;我们分别对于以上三道题目进行分析，给出解题思路。 首先，对于第一道跳台阶的问题，首先我们考虑最简单的情况，只有一级台阶，显然只有一种跳法。如果有两级台阶，那就有两种：一种是分两次跳，每次跳一级；另一种是一次跳两级。更一般的情况，当有n级台阶（n&gt;2)的时候，第一次跳就有两种不同的选择：一是一次跳一级，此时跳法数目等于后面剩下的n-1级台阶的跳法数目，我们用f(n-1)表示；另外一种选择是一次跳两级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，也就是f(n-2)。因此n级台阶的不同跳法的总数f(n)=f(n-1)+f(n-2)，很显然斐波那契数列嘛！！ 这道题目我们可以看出与上一题目的改变就是，青蛙的会的跳法数和台阶数是一致的，但是这不完全是斐波那契数列，下面我们来分析一下： &ensp;&ensp;（1）假定第一次跳的是一阶，那么剩下的是n-1个台阶，跳法是f(n-1)；假定第一次跳的是2阶，那么剩下的是n-2个台阶，跳法是f(n-2)；假定第一次跳的是3阶，那么剩下的是n-3个台阶，跳法是f(n-3)……假定第一次跳的是n-1阶，那么剩下的是1个台阶，跳法是f(1)； 假定第一次跳的是n阶，那么剩下的是0个台阶，跳法是1种；&ensp;&ensp;（2）总跳法为: f(n) = 1+f(n-1) + f(n-2)+….+f(1) （第一个1是跳n阶只有一种方法）&ensp;&ensp;（3）根据（2）可以得出有一阶的时候 f(1) = 1 ；有两阶的时候可以有 f(2) = 1+f(1)=2；有三阶的时候可以有 f(3) = 1+f(2)+f(1)=4…依次内推，有n阶时f(n)=2^(n-1)。 &ensp;&ensp;很容易就可以归纳出来这里结论，更简单的来想一下：每个台阶都有跳与不跳两种情况（除了最后一个台阶），最后一个台阶必须跳。所以共用2^(n-1)中情况。 &ensp;&ensp;归纳出来了表达式，可以看出这是一个乘方形式，而且还是2的乘方，为什么是2的乘方我们那么开心呢？哦原来我们平时一直在用的计算机不就是二进制形式工作的吗，那我们还用循环或者递归实现么，显然拒绝时间开销，拒绝递归调用，位运算给我们提供了很好帮助，一行代码搞定： 1return 1&lt;&lt;--number; 下面来分析第三个问题，这个填充的问题应该很多同学小学的时候没少做这样的问题吧，但是当时我们并没有深入去了解这个问题，也没有总结这个题目背后的规律。我们把28的覆盖方法记为f(8)。用21的小矩形去覆盖大矩形时，很显然两种方法：横着、竖着。当竖着放时，右边还剩下27的区域，如下图所示，这种情况下覆盖方法记为f(7)。接下来考虑横着放的情况，当放在左上角时，左下角必须也放一个横着的小矩形，那么剩下26的区域，这种情况下的覆盖方法记为f(6)，因此f(8) = f(7)+f(6)，看又熟悉了吧，斐波那契数列啊！！！ 三 、总结&ensp;&ensp;通过这几道题目的分析，我们可以得出一个结论：那就是要活学活用自己学到的知识，要学会举一反三，如何分析问题并将其抽象成我们已经掌握的知识可解决的问题，这种能力才是我们今后学习的过程中要不断提高加强的！！！","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"递归,循环","slug":"递归-循环","permalink":"http://winterfu.github.io/tags/递归-循环/"}]},{"title":"排序（四）：选择排序","slug":"排序4：选择排序","date":"2018-01-04T09:06:48.000Z","updated":"2018-01-04T11:09:30.228Z","comments":true,"path":"2018/01/04/排序4：选择排序/","link":"","permalink":"http://winterfu.github.io/2018/01/04/排序4：选择排序/","excerpt":"摘要：选择排序（Selection Sort)是一种最简单直接的排序算法。 一、前言&ensp;&ensp;选择排序是一种简单直接的选择排序算法，每趟在未排序的数列中找到最小（或者最大）的元素，然后将其放在数列的起始（或末尾）位置。","text":"摘要：选择排序（Selection Sort)是一种最简单直接的排序算法。 一、前言&ensp;&ensp;选择排序是一种简单直接的选择排序算法，每趟在未排序的数列中找到最小（或者最大）的元素，然后将其放在数列的起始（或末尾）位置。 二、算法思想&ensp;&ensp;首先在未排序的数列中找到最小(or最大)元素，然后将其存放到数列的起始(or末尾)位置；接着，再从剩余未排序的元素中继续寻找最小(or最大)元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。 1、算法图解&ensp;&ensp;以数列{20,40,30,10,60,50}为例，演示其选择排序过程，示意图如下： &ensp;&ensp;排序流程如下： 第1趟：i=0。找出a[1…5]中的最小值a[3]=10，然后将a[0]和a[3]互换。 数组变化：20,40,30,10,60,50– &gt; 10,40,30,20,60,50 第2趟：i=1。找出a[2…5]中的最小值a[3]=20，然后将a[1]和a[3]互换。 数组变化：10,40,30,20,60,50– &gt; 10,20,30,40,60,50 第3趟：i=2。找出a[3…5]中的最小值，由于该最小值大于a[2]，该趟不做任何处理。 第4趟：i=3。找出a[4…5]中的最小值，由于该最小值大于a[3]，该趟不做任何处理。 第5趟：i=4。交换a[4]和a[5]的数据。 数组变化：10,20,30,40,60,50 – &gt; 10,20,30,40,50,60 2、具体实现&ensp;&ensp; 根据上面的思路，不难写出选择排序的实现，首先我们用C/C++实现: 1234567891011121314151617181920212223242526272829#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 简单选择排序vector&lt;int&gt; SelectSort(vector&lt;int&gt; list)&#123; // 需要遍历获得最小值的次数 // 要注意一点，当要排序 N 个数，已经经过 N-1 次遍历后，已经是有序数列 vector&lt;int&gt; result = list; for (int i = 0; i &lt; result.size(); i++)&#123; // 用来保存最小值得索引 int index = i; // 用来保存最小值得索引 for (int j = i + 1; j &lt; result.size(); j++)&#123; if (result[index] &gt; result[j])&#123; index = j; &#125; &#125; // 将找到的第i个小的数值放在第i个位置上 swap(result[i], result[index]); cout &lt;&lt; \"第\" &lt;&lt; i + 1&lt;&lt; \"趟:\\t\"; for (int i = 0; i &lt; result.size(); i++)&#123; cout &lt;&lt; result[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; return result;&#125; &ensp;&ensp;人生苦短，我用Python: 12345678910def select_sort(lists): # 选择排序 count = len(lists) for i in range(0, count): min = i for j in range(i + 1, count): if lists[min] &gt; lists[j]: min = j lists[min], lists[i] = lists[i], lists[min] return lists 三、时间空间复杂度及算法稳定性分析&ensp;&ensp;选择排序的时间复杂度是O(N2)：假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次因此，选择排序的时间复杂度是O(N2)。 &ensp;&ensp;选择排序需要占用一个临时空间，用于保存最小值的索引，所以空间复杂度是1. &ensp;&ensp;选择排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,选择","slug":"排序-选择","permalink":"http://winterfu.github.io/tags/排序-选择/"}]},{"title":"排序（三）：直接插入排序","slug":"排序3：直接插入排序","date":"2018-01-04T03:00:36.000Z","updated":"2018-01-04T09:06:16.052Z","comments":true,"path":"2018/01/04/排序3：直接插入排序/","link":"","permalink":"http://winterfu.github.io/2018/01/04/排序3：直接插入排序/","excerpt":"摘要：直接插入排序（Straight Insertion Sort)是一种最简单的插入排序，每次将无序部分的元素放到有序部分来即可。 一、前言&ensp;&ensp;快速排序是一种简单的插入排序算法，为了简单起见，这里我们只讨论升序排序。","text":"摘要：直接插入排序（Straight Insertion Sort)是一种最简单的插入排序，每次将无序部分的元素放到有序部分来即可。 一、前言&ensp;&ensp;快速排序是一种简单的插入排序算法，为了简单起见，这里我们只讨论升序排序。 二、算法思想&ensp;&ensp;把n个待排序的元素看成为一个有序表和一个无序表。开始时有序表中只包含1个元素，无序表中包含有n-1个元素，排序过程中每次从无序表中取出第一个元素，将它插入到有序表中的适当位置，使之成为新的有序表，重复n-1次可完成排序过程。 1、算法图解&ensp;&ensp;下面选取直接插入排序的一个中间过程对其进行说明。假设{20,30,40,10,60,50}中的前3个数已经排列过，是有序的了；接下来对10进行排列。示意图如下： &ensp;&ensp;图中将数列分为有序区和无序区。我们需要做的工作只有两个：(1)取出无序区中的第1个数，并找出它在有序区对应的位置。(2)将无序区的数据插入到有序区；若有必要的话，则对有序区中的相关数据进行移位。看，是不是很简单。 2、具体实现&ensp;&ensp; 根据上面的思路，不难写出直接插入排序的实现，首先我们用C/C++实现: 1234567891011121314151617181920212223242526#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;vector&lt;int&gt; insertsort(vector&lt;int&gt; list)&#123; vector&lt;int&gt; result; if(list.empty())&#123; return result; &#125; result = list; // 第一个数肯定是有序的，从第二个数开始遍历，一次插入到有序序列 for（int i = 1; i &lt; result.size(); i++)&#123; // 取出第i个数，在前i-1个数中找一个合适位置 int temp = result[i]; int j = i - 1; for(j; j &gt;= 0 &amp;&amp; result[j] &gt; temp; j--)&#123; result[j+1] = result[j] &#125; result[j+1] = temp; &#125; return result;&#125; &ensp;&ensp;人生苦短，我用Python: 123456789101112def insert_sort(lists): # 插入排序 count = len(lists) for i in range(1, count): key = lists[i] j = i - 1 while j &gt;= 0: if lists[j] &gt; key: lists[j + 1] = lists[j] lists[j] = key j -= 1 return lists &ensp;&ensp;ke可以看到插入排序要做的事情就是每次从无序序列中拿一个元素，然后在有序序列中找一个合适的位置将其插入，以保证有序序列的序列次序不变，可以使用二分查找，较少元素比较次数提高效率，这可以作为算法优化的点。 &ensp;&ensp;所谓二分查找是对于有序数组而言的，假设如果数组是升序排序的。那么，二分查找算法就是不断对数组进行对半分割，每次拿中间元素和目标数字进行比较，如果中间元素小于目标数字，则说明目标数字应该在左侧被分割的数组中，如果中间元素大于目标数字，则说明目标数字应该在右侧被分割的数组中。具体实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;iostream&gt;#include &lt;vector&gt;using namespace std;// 给定一个有序的数组，查找第一个大于等于value的下标，不存在返回-1int BinarySearch(vector&lt;int&gt; list, int n, int value)&#123; int left = 0; int right = n - 1; while (left &lt;= right)&#123; int middle = left + ((right - left) &gt;&gt; 1); if (list[middle] &gt;= value)&#123; right = middle - 1; &#125; else&#123; left = middle + 1; &#125; &#125; return (left &lt; n) ? left : -1;&#125;vector&lt;int&gt; BinaryInsertSort(vector&lt;int&gt; list)&#123; vector&lt;int&gt; result = list; for (int i = 1; i &lt; result.size(); i++)&#123; int insert_index = BinarySearch(result, i, result[i]); if (insert_index != -1)&#123; int temp = result[i]; int j = i - 1; while (j &gt;= insert_index)&#123; result[j + 1] = result[j]; j--; &#125; result[j + 1] = temp; &#125; printf(\"第 %d 趟： \", i); for (int i = 0; i &lt; result.size(); i++)&#123; cout &lt;&lt; result[i] &lt;&lt; \" \"; &#125; cout &lt;&lt; endl; &#125; return result;&#125; &ensp;&ensp;查找插入位置的次数减少了，提高了算法效率。 三、时间空间复杂度及算法稳定性分析&ensp;&ensp;直接插入排序的时间复杂度是O(N2)：假设被排序的数列中有N个数，遍历一趟时间复杂度是O(N)，需遍历多少次呢？N-1次，因此，其时间复杂度是O(N2)。 &ensp;&ensp;由直接插入排序法可知，我们在排序的过程中，需要一个临时变量存储要插入的值，所以空间复杂度为1.&ensp;&ensp;直接插入排序是稳定的算法，它满足稳定算法的定义：假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,插入","slug":"排序-插入","permalink":"http://winterfu.github.io/tags/排序-插入/"}]},{"title":"排序(二）：快速排序","slug":"排序2：快速排序","date":"2018-01-04T01:57:02.000Z","updated":"2018-01-04T03:24:59.183Z","comments":true,"path":"2018/01/04/排序2：快速排序/","link":"","permalink":"http://winterfu.github.io/2018/01/04/排序2：快速排序/","excerpt":"摘要：快速排序（Quick Sort)是一种“分治策略”，每次将要排列的数组二分治之，递归调用，直至满足条件。 一、前言&ensp;&ensp;快速排序是一种简单的排序算法，也是一种二分排序。&ensp;&ensp;所谓二分排序就是不断地将数列分成两部分然后进行递归排序。","text":"摘要：快速排序（Quick Sort)是一种“分治策略”，每次将要排列的数组二分治之，递归调用，直至满足条件。 一、前言&ensp;&ensp;快速排序是一种简单的排序算法，也是一种二分排序。&ensp;&ensp;所谓二分排序就是不断地将数列分成两部分然后进行递归排序。 二、算法思想&ensp;&ensp;选择一个基准数，通过一趟排序将要排序的数据分割成独立的两部分；其中一部分的所有数据都比另外一部分的所有数据都要小。然后，再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。 1、算法图解&ensp;&ensp;快速排序的算法流程如下： 从数列中挑出一个基准值 将所有比基准值小的摆在基准前面，所有比基准大的摆在基准的后面（相同的数可以放在任意一遍）；在这个分区退出后，该基准就处于数列的中间位置。 递归地把“基准值前面的子数列”和“基准值后面的子数列”进行排序 &ensp;&ensp;快速排序图文说明：下面以数列a = {30，40，60，10，20，50}为例，演示它的快速排序过程（如下图）。&ensp;&ensp;上图只是给出了第1趟快速排序的流程。第1趟流程中，首先设置基数x=a[i]=a[0],即x=30.我们首先分析第一趟排序： 从”右 –&gt; 左”查找小于x的数：找到满足条件的 数 a[j]=20，此时j=4；然后将a[j]赋值a[i]，此时i=0；接着从左往右遍历； 从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=40，此时i=1；然后将a[i]赋值a[j]，此时j=4；接着从右往左遍历； 从”右 –&gt; 左”查找小于x的数：找到满足条件的数a[j]=10，此时j=3；然后将a[j]赋值a[i]，此时i=1；接着从左往右遍历。 从”左 –&gt; 右”查找大于x的数：找到满足条件的数a[i]=60，此时i=2；然后将a[i]赋值a[j]，此时j=3；接着从右往左遍历。 从”右 –&gt; 左”查找小于x的数：没有找到满足条件的数。当i&gt;=j 时，停止查找；然后将x赋值给a[i]。第一趟遍历结束！ 2、具体实现&ensp;&ensp; 根据上面的思路，不难写出快速排序的实现，首先我们用C/C++实现: 12345678910111213141516171819202122232425262728293031323334/** 快速排序** 参数说明：* a -- 待排序的数组* l -- 数组的左边界(例如，从起始位置开始排序，则l=0)* r -- 数组的右边界(例如，排序截至到数组末尾，则r=a.length-1)**/void quick_sort(int a[], int l, int r)&#123; if (l &lt; r) &#123; int i,j,x; i = l; j = r; x = a[i]; while (i &lt; j) &#123; while(i &lt; j &amp;&amp; a[j] &gt; x) j--; // 从右向左找第一个小于x的数 if(i &lt; j) a[i++] = a[j]; while(i &lt; j &amp;&amp; a[i] &lt; x) i++; // 从左向右找第一个大于x的数 if(i &lt; j) a[j--] = a[i]; &#125; a[i] = x; quick_sort(a, l, i-1); /* 递归调用 */ quick_sort(a, i+1, r); /* 递归调用 */ &#125;&#125; &ensp;&ensp;人生苦短，我用Python: 12345678910111213141516171819202122232425262728293031def quick_sort(lists, left, right): # 快速排序 if left &gt;= right: return lists key = lists[left] low = left high = right while left &lt; right: while left &lt; right and lists[right] &gt;= key: right -= 1 lists[left] = lists[right] while left &lt; right and lists[left] &lt;= key: left += 1 lists[right] = lists[left] lists[right] = key quick_sort(lists, low, left - 1) quick_sort(lists, left + 1, high) return listsdef quicksort(arr): if len(arr) &lt;= 1: return arr pivot = arr[len(arr) / 2] left = [x for x in arr if x &lt; pivot] middle = [x for x in arr if x == pivot] right = [x for x in arr if x &gt; pivot] return quicksort(left) + middle + quciksort(right) 三、时间复杂度及算法稳定性分析&ensp;&ensp;快速排序的时间复杂度：快速排序的时间复杂度在最坏情况下是O(N2)，平均的时间复杂度是O(N*lgN)。这句话很好理解：假设被排序的数列中有N个数。遍历一次的时间复杂度是O(N)，需要遍历多少次呢？至少lg(N+1)次，最多N次。 &ensp;&ensp;为什么最少是lg(N+1)次？快速排序是采用的分治法进行遍历的，我们将它看作一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的定义，它的深度至少是lg(N+1)。因此，快速排序的遍历次数最少是lg(N+1)次。 &ensp;&ensp;为什么最多是N次？这个应该非常简单，还是将快速排序看作一棵二叉树，它的深度最大是N。因此，快读排序的遍历次数最多是N次。 &ensp;&ensp;快速排序的稳定性：快速排序是不稳定的算法，它不满足稳定算法的定义；所谓算法稳定性指的是对于一个数列中的两个相等的数a[i]=a[j]，在排序前,a[i]在a[j]前面，经过排序后a[i]仍然在a[j]前，那么这个排序算法是稳定的。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,快排","slug":"排序-快排","permalink":"http://winterfu.github.io/tags/排序-快排/"}]},{"title":"排序(一)：冒泡排序","slug":"排序1：冒泡排序","date":"2018-01-04T01:15:47.000Z","updated":"2018-01-04T07:51:07.030Z","comments":true,"path":"2018/01/04/排序1：冒泡排序/","link":"","permalink":"http://winterfu.github.io/2018/01/04/排序1：冒泡排序/","excerpt":"摘要：冒泡排序是一种交换排序。什么是交换排序呢？答曰：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。 一、前言&ensp;&ensp;冒泡排序是一种简单的排序算法，也是一种交换排序。&ensp;&ensp;所谓交换排序就是不断地进行两两比较，满足条件则交换，不满足不交换。","text":"摘要：冒泡排序是一种交换排序。什么是交换排序呢？答曰：两两比较待排序的关键字，并交换不满足次序要求的那对数，直到整个表都满足次序要求为止。 一、前言&ensp;&ensp;冒泡排序是一种简单的排序算法，也是一种交换排序。&ensp;&ensp;所谓交换排序就是不断地进行两两比较，满足条件则交换，不满足不交换。 二、算法思想&ensp;&ensp;它会遍历若干次要排序的数列，每次遍历时，它都会从前往后依次的比较相邻两个数的大小；如果前者比后者大，则交换它们的位置。这样，一次遍历之后，最大的元素就在数列的末尾！ 采用相同的方法再次遍历时，第二大的元素就被排列在最大元素之前。重复此操作，直到整个数列都有序为止！ 1、算法图解&ensp;&ensp;下面以数列{20,40,30,10,60,50}为例，演示它的冒泡排序过程(如下图)。&ensp;&ensp;我们首先分析第一趟排序： 第一趟排完之后，最大元素60移到数组最后了，也就是a[5]此时为数组中最大的元素，再进行第二趟排序的时候，只需按照上面的方法排前面5个元素就可以了。这样：第2趟排序完之后，数列中a[4]、a[5]是有序的。第3趟排序完之后，数列中a[3]、a[4]、a[5]是有序的。第4趟排序完之后，数列中a[2]、[3]、a[4]、a[5]是有序的。第5趟排序完之后，数列中a[1]、a[2]、[3]、a[4]、a[5]是有序的。第5趟排序之后，整个数列也就是有序的了。 2、具体实现&ensp;&ensp; 根据上面的流程，不难写出冒泡排序的实现，首先我们用C/C++实现，此处是按升序排序: 12345678910111213141516171819202122void bubble_sort(int a[], int n)&#123; int i,j; for (i=n-1; i&gt;0; i--) &#123; // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) swap(a[j], a[j+1]); &#125; &#125;&#125;void swap(int x, int y)&#123; int temp; temp = x; x = y; y = temp;&#125; &ensp;&ensp; 其实观察上面例子冒泡排序的流程图，第3趟排序之后，数据已经是有序的了；第4趟和第5趟并没有进行数据交换。因此可以对冒泡排序进行优化，使它效率更高一些：添加一个标记，如果一趟遍历中发生了交换，则标记为true，否则为false。如果某一趟没有发生交换，说明排序已经完成，退出。优化后的代码如下： 1234567891011121314151617181920void bubble_sort2(int a[], int n)&#123; int i,j; int flag; // 标记一趟是否发生交换 for (i=n-1; i&gt;0; i--) &#123; flag = 0; // 初始化标记为0 // 将a[0...i]中最大的数据放在末尾 for (j=0; j&lt;i; j++) &#123; if (a[j] &gt; a[j+1]) &#123; swap(a[j], a[j+1]); flag = 1; //发生交换，设flag为1 &#125; &#125; if (flag==0) break; // 若无交换，说明数列已有序 &#125;&#125; &ensp;&ensp;人生苦短，我用Python: 12345678910111213141516# -*- coding:utf-8 -*- def bubbleSort(input_list): if len(input_list)def bubble_sort(lists): # 冒泡排序 if len(lists) == 0: return [] count = len(lists) for i in range(count): for j in range(i + 1, count): if lists[i] &gt; lists[j]: lists[i], lists[j] = lists[j], lists[i] return lists 三、时间复杂度及算法稳定性分析&ensp;&ensp;冒泡排序的时间复杂度是O(N2)：假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？N-1次！因此，冒泡排序的时间复杂度O(N2)。 &ensp;&ensp;冒泡排序是稳定的算法：它满足稳定算法的定义；所谓算法稳定性指的是对于一个数列中的两个相等的数a[i]=a[j]，在排序前,a[i]在a[j]前面，经过排序后a[i]仍然在a[j]前，那么这个排序算法是稳定的。","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"排序,冒泡","slug":"排序-冒泡","permalink":"http://winterfu.github.io/tags/排序-冒泡/"}]},{"title":"剑指Offer(七)：斐波那契数列","slug":"剑指Offer-7：菲波那切数列","date":"2017-12-26T13:36:12.000Z","updated":"2018-01-10T08:05:28.280Z","comments":true,"path":"2017/12/26/剑指Offer-7：菲波那切数列/","link":"","permalink":"http://winterfu.github.io/2017/12/26/剑指Offer-7：菲波那切数列/","excerpt":"摘要：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp;大家都知道斐波那契数列，现在要求输入一个整数n，请你输出斐波那契数列的第n项。 1、思路&ensp;&ensp;斐波那切数列，相信大家都不陌生吧，对就是那个我们小时候常做的问题，什么小兔子生兔子的问题，还有一些花的花瓣数也是符合斐波那契数列的规律的，因此也称其为“迷人的斐波那契数列”，在数学上，斐波那契数列以递归的方式定义：F(0) = 0，F(1) = 1， F(n) = F(n-1) + F(n-2) (n&gt;=2，n为正整数) 2、具体实现&ensp;&ensp; C/C++:1.首先我们就可以按照其定义方式，用递归的思想来实现： 12345678class Solution &#123;public: int Fibonacci(int n) &#123; if(n&lt;=0) return 0; if(n==1 || n==2) return 1; return Fibonacci(n-1)+Fibonacci(n-2); &#125;&#125;; 这里存在一个问题就是，当n比较大的时候会出现溢出的情况。 2.动态规划的思想 1234567891011class Solution &#123;public: int Fibonacci(int n) &#123; int f = 0, g = 1; while(n--) &#123; g += f; f = g - f; &#125; return f; &#125;&#125;; 3.全面考虑，把负数，大数，算法的复杂度，空间浪费都考虑进来 12345678910111213141516171819202122232425262728public class Solution &#123; public int Fibonacci(int n) &#123; //方法1：用递归，系统会让一个超大的n来让Stack Overflow，所以 //递归就不考虑了 //使用迭代法，用fn1和fn2保存计算过程中的结果，并复用起来 int fn1 = 1; int fn2 = 1; //考虑出错情况 if (n &lt;= 0) &#123; return 0; &#125; //第一和第二个数直接返回 if (n == 1 || n == 2) &#123; return 1; &#125; //当n&gt;=3时，走这里，用迭代法算出结果 //这里也说明了，要用三个数操作的情况，其实也可以简化为两 //个数，从而节省内存空间 while (n-- &gt; 2) &#123; fn1 += fn2; fn2 = fn1 - fn2; &#125; return fn1; &#125;&#125; 4.尾递归，递归总归来说是栈，可能导致栈溢出 12345678910111213public class Solution &#123; public int Fibonacci(int n) &#123; return Fibonacci(n,0,1); &#125; private static int Fibonacci(int n,int acc1,int acc2)&#123; if(n==0) return 0; if(n==1) return acc2; else return Fibonacci(n - 1, acc2, acc1 + acc2); &#125;&#125; &ensp;&ensp;人生苦短，我用Python:1.递归实现 12345678def fib(n): return 1 if n&lt;=1 else fib(n-1)+fib(n-2) #很简单的一个三目运算符实现def fib(n): dic = &#123; 0:1, 1: 1&#125; if n&lt;=1: return dict[n] retrun fib(n-1)+fib(n-2) PS：递归还有一个缺点就是需要进行很多次重复的运算 2.完美实现方案1 12345678910def fib1(n): stack =[] if n==0 or n==1: return 1 else: stack.append(1) stack.append(1) for i in range(2,n): stack.append(stack[i-1] + stack[i-2]) retrun stack 3.完美实现方案2 1234567def fib2(number): x, y = 0, 1 result = [] while y &lt; number: result.append(y) x, y = y, x+y return result 4.完美实现方案3，吧其编程一个生成器的形式，可以使用循环将其输出出来 123456789def fib3(): x, y = 0, 1 while True: yeild x x, y = y, x+yif __name__ == \"__main__\": import itertools print(list(itertools.islice(fib(), 10))","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"递归,循环","slug":"递归-循环","permalink":"http://winterfu.github.io/tags/递归-循环/"}]},{"title":"剑指Offer(六)：旋转数组的最小数字","slug":"剑指Offer-6：旋转数组的最小数字","date":"2017-12-25T13:44:03.000Z","updated":"2017-12-26T13:38:23.616Z","comments":true,"path":"2017/12/25/剑指Offer-6：旋转数组的最小数字/","link":"","permalink":"http://winterfu.github.io/2017/12/25/剑指Offer-6：旋转数组的最小数字/","excerpt":"摘要：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp;把一个数组最开始的若干个元素搬到数组的末尾，我们称之为数组的旋转。 输入一个非递减排序的数组的一个旋转，输出旋转数组的最小元素。 例如数组{3,4,5,1,2}为{1,2,3,4,5}的一个旋转，该数组的最小值为1。 NOTE：给出的所有元素都大于0，若数组大小为0，请返回0。 1、思路&ensp;&ensp;首先要注意有无重复数字，也就是是否严格递增。这是一道二分查找的变形题目，旋转后的之后的数字实际上可以划分为两个有序的子数组：前面的数组中的元素大小都大于后面子数组中的元素。&ensp;&ensp;不难发现实际上最小的元素就是两字子数组的分界线。本题目给出的数组一定程度上是排好序的，因此我们可以采用二分法来查找。 我们用两个指针left,right分别指向数组的第一个元素和最后一个元素。按照题目的旋转的规则，第一个元素应该是大于最后一个元素的（没有重复的元素）。但是如果不旋转，第一个元素肯定是小于最后一个元素的。 找到数组的中间元素：1&gt;中间元素大于第一个元素，则中间元素位于前面的递增子数组，此时最小元素位于中间元素的后面。我们可以让第一个指针left指向中间元素。移动之后，第一个指针仍然位于前面的递增数组中。 2&gt;中间元素小于第一个元素，则中间元素位于后面的递增子数组，此时最小元素位于中间元素的前面。我们可以让第二个指针right指向中间元素。移动后，第二个指针仍然位于后面的递增数组中。这样即可缩小寻找的范围。 按照以上思路，第一个指针left总是指向前面递增数组的元素，第二个指针right总是指向后面递增的数组元素。最终第一个指针将指向前面数组的最后一个元素，第二个指针指向后面数组中的第一个元素。也就是说他们将指向两个相邻的元素，而第二个指针指向的刚好是最小的元素，这就是循环的结束条件。 &ensp;&ensp;到目前为止以上思路很好的解决了没有重复数字的情况，这一道题目添加上了这一要求，有了重复数字。因此这一道题目比上一道题目多了些特殊情况： &ensp;&ensp;我们看一组例子：｛1，0，1，1，1｝ 和 ｛1，1， 1，0，1｝ 都可以看成是递增排序数组｛0，1，1，1，1｝的旋转。 &ensp;&ensp;这种情况下我们无法继续用上一道题目的解法，去解决这道题目。因为在这两个数组中，第一个数字，最后一个数字，中间数字都是1。第一种情况下，中间数字位于后面的子数组，第二种情况，中间数字位于前面的子数组。 &ensp;&ensp;因此当两个指针指向的数字和中间数字相同的时候，我们无法确定中间数字1是属于前面的子数组（绿色表示）还是属于后面的子数组（紫色表示）。也就无法移动指针来缩小查找范围了。 2、具体实现&ensp;&ensp; C/C++: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;string&gt;#include &lt;stack&gt;#include &lt;algorithm&gt;using namespace std; class Solution &#123;public: int minNumberInRotateArray(vector&lt;int&gt; rotateArray) &#123; int size = rotateArray.size(); if(size == 0)&#123; return 0; &#125; int left = 0,right = size - 1; int mid = 0; while(rotateArray[left] &gt;= rotateArray[right])&#123; // 分界点 if(right - left == 1)&#123; mid = right; break; &#125; mid = left + (right - left) / 2; // rotateArray[left] rotateArray[right] rotateArray[mid]三者相等 // 无法确定中间元素是属于前面还是后面的递增子数组 // 只能顺序查找 if(rotateArray[left] == rotateArray[right] &amp;&amp; rotateArray[left] == rotateArray[mid])&#123; return MinOrder(rotateArray,left,right); &#125; // 中间元素位于前面的递增子数组 // 此时最小元素位于中间元素的后面 if(rotateArray[mid] &gt;= rotateArray[left])&#123; left = mid; &#125; // 中间元素位于后面的递增子数组 // 此时最小元素位于中间元素的前面 else&#123; right = mid; &#125; &#125; return rotateArray[mid]; &#125;private: // 顺序寻找最小值 int MinOrder(vector&lt;int&gt; &amp;num,int left,int right)&#123; int result = num[left]; for(int i = left + 1;i &lt; right;++i)&#123; if(num[i] &lt; result)&#123; result = num[i]; &#125; &#125; return result; &#125;&#125;; int main()&#123; Solution s; //vector&lt;int&gt; num = &#123;0,1,2,3,4,5&#125;; //vector&lt;int&gt; num = &#123;4,5,6,7,1,2,3&#125;; vector&lt;int&gt; num = &#123;2,2,2,2,1,2&#125;; int result = s.minNumberInRotateArray(num); // 输出 cout&lt;&lt;result&lt;&lt;endl; return 0; &#125; &ensp;&ensp;人生苦短，我用Python: 1234567891011121314151617181920212223# -*- coding: utf-8 -*-def find_rotation_array_min(roation_array): n = len(roation_array) if roation_array[0] &lt; roation_array[-1]: return 0 left = 0 right = n-1 while roation_array[left] &gt;= roation_array[right]: if right-left == 1: mid = right break mid = left + int((right - left) / 2) if(roation_array[left]==roation_array[right] and roation_array[left] == roation_array[mid]): return min(roation_array) if(roation_array[mid] &gt;= roation_array[left]): left =mid else: right=mid return roation_array[mid]if __name__ == \"__main__\": s = [2, 2, 2, 2, 1, 2] q = [3,4,5,1,2] print(find_rotation_array_min(s), find_rotation_array_min(q))","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"数组,查找,排序","slug":"数组-查找-排序","permalink":"http://winterfu.github.io/tags/数组-查找-排序/"}]},{"title":"浅谈神经网络中激励函数的作用","slug":"浅谈神经网络中激励函数的作用","date":"2017-12-25T11:30:25.000Z","updated":"2017-12-25T13:11:35.278Z","comments":true,"path":"2017/12/25/浅谈神经网络中激励函数的作用/","link":"","permalink":"http://winterfu.github.io/2017/12/25/浅谈神经网络中激励函数的作用/","excerpt":"什么是激活函数？&ensp;&ensp;我想z这一点也不用多说，无论是搞机器学习还是深度学习的对于激活函数这个名词已经再熟悉不过了，因为搭建网络的时候都会要用到它，虽然我们无时无刻都在使用它，但是我们真的知其然也知其所以然么？ 首先问自己一个问题，在解决复杂问题用的神经网络模型中如果没有激活函数可以么？ 很显然，不可以！！！ &ensp;&ensp;那么肯定又会有人问了为什么不可以，那有无激活函数又有什么区别，激活函数的作用又是什么呢？","text":"什么是激活函数？&ensp;&ensp;我想z这一点也不用多说，无论是搞机器学习还是深度学习的对于激活函数这个名词已经再熟悉不过了，因为搭建网络的时候都会要用到它，虽然我们无时无刻都在使用它，但是我们真的知其然也知其所以然么？ 首先问自己一个问题，在解决复杂问题用的神经网络模型中如果没有激活函数可以么？ 很显然，不可以！！！ &ensp;&ensp;那么肯定又会有人问了为什么不可以，那有无激活函数又有什么区别，激活函数的作用又是什么呢？ &ensp;&ensp;且听我慢慢道来：&ensp;&ensp;首先回答，为什么不可以，神经网络之所以很强大，能够解决很多复杂问题，很重要的一点就是其引入了非线性，那么是通过什么引入的呢？没错就是你想的那样，通过激活函数，这样它才能够解决一些复杂的非线性问题，如果没有激活函数，或者是线性激活函数，那么就跟普通的线性方程别无二致了，这肯定不是我们想要的。 激活函数的作用 激活函数是用来加入非线性因素的，解决线性模型所不能解决的问题 激活函数可以用来组合训练数据的特征，使特征充分组合 &ensp;&ensp;在这里第一个特点上面我们也提到了，主要是用来引入非线性，提高神经网络的表达能力，更好的解决复杂的非线性问题。单层感知机解决不了异或问题，多层感知机可以解决异或但是再加入一点非线性其能力还是很弱，这已经是个老生常谈的话题了。 &ensp;&ensp;下面主要从第二个特点我们进行说明一下： &ensp;&ensp;首先我们看一个简单的感知机的例子： &ensp;&ensp;其中，x1和x2为特征输入，x3 = w1 x1 + w2 x2，激活函数采用sigmoid函数，公式表达式如下： 则 &ensp;&ensp;此时，我们可能看不出什么不同，下面我们进行泰勒展开， &ensp;&ensp;通过泰勒展开。我们不难看到，我们已经构造出立方激活函数的形式了，我们能够看到，将x3带入到激活函数中时，将激活函数中的指数项按照泰勒级数展开后，就会有平方项，立方项，有更高的项，这些能够把输入特征进行亮亮组合，进行三三组合或者其他组合。 总结&ensp;&ensp;激活函数在神经网络模型的构建中必不可少，能够引入一定的非线性因素，增强网络的表达能力；此外还可以把原来需要领域知识的专家对特征进行组合的情况，在激活函数运算后，其实也能够起到特征组合的作用。（只要激活函数中能有用泰勒级数展开的函数，就可以对特征起到组合的作用）","categories":[{"name":"机器学习","slug":"机器学习","permalink":"http://winterfu.github.io/categories/机器学习/"}],"tags":[{"name":"激活函数,sigmoid","slug":"激活函数-sigmoid","permalink":"http://winterfu.github.io/tags/激活函数-sigmoid/"}]},{"title":"剑指Offer(五)：栈和队列","slug":"剑指Offer-5：栈和队列","date":"2017-12-21T14:09:03.000Z","updated":"2017-12-21T14:26:45.285Z","comments":true,"path":"2017/12/21/剑指Offer-5：栈和队列/","link":"","permalink":"http://winterfu.github.io/2017/12/21/剑指Offer-5：栈和队列/","excerpt":"摘要：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp;用两个栈来实现一个队列，完成队列的Push和Pop操作。 队列中的元素为int类型。 1、思路&ensp;&ensp;这道题目首先要知道队列和栈各自的特点，那么接下来就按照这种特点去设计即可： 入队：将元素进栈A 出队：判断栈B是否为空，如果为空，则将栈A中所有的元素pop，并push进栈B，栈B出栈；如果不为空则栈B直接出栈。 &ensp;&ensp;这里同样可以用两个队列实现一个栈的功能： 入栈：将元素进队列A 出栈：判断队列A中元素个数是否为1，如果等于1则出队列，否则将队列A中的元素，一次出队列并放入队列B中，直到队列A中的元素留下最后一个，然后队列A出队列，再把队列B中的元素出队列一次放入队列A中。 2、具体实现&ensp;&ensp; C/C++: 1234567891011121314151617181920212223class Solution&#123;public: void push(int node) &#123; stack1.push(node); &#125; int pop() &#123; int temp; if(stack2.empty())&#123; while(!stack1.empty())&#123; temp = stack1.top(); stack2.push(temp); stack1.pop(); &#125; &#125; temp = stack2.top(); stack2.pop(); return temp; &#125;private: stack&lt;int&gt; stack1; stack&lt;int&gt; stack2;&#125;; &ensp;&ensp;人生苦短，我用Python: 1234567891011121314151617181920# -*- coding:utf-8 -*-class Solution: def __init__(self): self.stackA = [ ] self.stackB = [ ] def push(self, node): # write code here self.stackA.append(node) def pop(self): # return xx if self.stackB: return self.stackB.pop() elif not self.stackA: return None else: while self.stackA: self.stackB.append(self.stackA.pop()) return self.stackB.pop()","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"队列,栈","slug":"队列-栈","permalink":"http://winterfu.github.io/tags/队列-栈/"}]},{"title":"全球AI挑战赛之场景分类赛后总结篇","slug":"全球AI挑战赛之场景分类赛后总结篇","date":"2017-12-21T11:28:37.000Z","updated":"2017-12-21T13:45:56.582Z","comments":true,"path":"2017/12/21/全球AI挑战赛之场景分类赛后总结篇/","link":"","permalink":"http://winterfu.github.io/2017/12/21/全球AI挑战赛之场景分类赛后总结篇/","excerpt":"&ensp;&ensp;全球AI挑战赛已经落下帷幕近半个月的时间了，虽然没拿到太好的名次，但是这次的实战确实是学到了不少东西，也填了不少的坑，也算是为以后的学习道路除去了很多绊脚石吧，这次和puke同学一起摸爬滚打了好些昼夜，最终坚持到了最后，下面就分享一下我们在这次比赛中的经历以及一些对于遇到的那些问题的解决方案，小的tricks吧。","text":"&ensp;&ensp;全球AI挑战赛已经落下帷幕近半个月的时间了，虽然没拿到太好的名次，但是这次的实战确实是学到了不少东西，也填了不少的坑，也算是为以后的学习道路除去了很多绊脚石吧，这次和puke同学一起摸爬滚打了好些昼夜，最终坚持到了最后，下面就分享一下我们在这次比赛中的经历以及一些对于遇到的那些问题的解决方案，小的tricks吧。 一、前言&ensp;&ensp;首先简单说一下这个比赛，全球AI挑战赛我门选择的是场景分类这个题目，主要的任务就是将所给图片进行80场景分类，之前的ImageNet也是做过类似的比赛数据集是places-365或者200之类的，这次的数据集规模相对ImageNet的规模要小，但是图片质量还是有的保障的，我们也是大致看了一下比赛数据集中的图片，训练集5W+张，验证集7000+张，测试集分为AB榜进行测试，规模和验证集差不多，图片二义性很强，而且存在严重的不均衡现象，有些图片真的是人都很难去区分，但是机器做的很不错，不得不又得吹嘘一把DeepLearning的强大啊，哈哈哈！ 二、快速接入&ensp;&ensp;下载数据集&ensp;&ensp;代码链接 三、项目要点概述 支持多个单模型进行集成，可选多种集成方式 支持多种集成方式间的任意组合和自动择优 支持间断训练后在训练时权重文件的择优选择 支持VGG16、VGG19、Resnet50、Inception-V3、Xception、Inception-Resnet-V2等模型 imgaug图片数据增强库替换Keras自带的图片预处理 四、血泪史 &ensp;&ensp;选好框架很重要！！！ &ensp;&ensp;Tensorflow现在最流行的框架应该没有之一了吧，然而就是个大坑没毛病。其实这是谷歌开发的给工程师用的，对于小白或者教学来说还是用起来比较费劲，那为何还这么流行呢，毕竟是大厂，都懂得。虽然之后的Tensorflow出现了TFlearn和slim等高级库，但是还是写起来比较繁琐，所以像我这么懒的人呢还是果断抛弃了他，投向了Keras的怀抱，当然还有一些什么Caffee、Pytorch、MXnet啥的，至于为什么选了Keras我自己也讲不出来，Keras写起来很简单，也有一些已经预训练好的模型，但是同样在训练时有很多坑，不过现在已经被填平好多了，下面就来说一说这些坑（欢迎其他同学指正，补充！） &ensp;&ensp;数据增强很重要！！！ &ensp;&ensp;Keras自带的图片增强远远不够的，这里选择了imgaug这个图片数据增强库，直接上图，这种效果是目前的Keras望尘莫及的，尽可能最大限度利用当前有限的数据集。提高1~3个百分点 &ensp;&ensp;尽可能的去并行处理！！！ &ensp;&ensp;训练任务交给GPU去做，新添加的imgaug图片处理方式之后，一个Epoch在1050Ti上耗时90mins+，排查发现大部分时间都在进行图片数据增强处理，于是将该部分的处理替换为多进程方式。时间从90mins降到30mins左右 &ensp;&ensp;数据标准化很重要！！！&ensp;&ensp;Keras是自带的标准化都不是最合理的，首先我们要计算出整体训练集三个通道各自的mean和std而不是单个数据，更不是单个batch的。然后在训练阶段的输入数据以mean和std进行高斯处理（注意验证集也要做一样的操作，这里是为了保证同分布），提高0.5~1.0个百分点。 &ensp;&ensp;Fine-tuning时别绑太紧！！！ &ensp;&ensp;这点尤为重要！Fine-tune时松太开，可能导致训练耗时，也可能导致机器带不动；绑太紧可能导致Fixed的权重参数扼制了模型的学习能力。建议是在机器能扛得住的基础下，尽可能松绑多一些，提高2~5个百分点。 &ensp;&ensp;模型选择很重要！！！ &ensp;&ensp;糟糕的模型训练几天几夜，可能赶不上优势模型训练几个epoch。VGG16=&gt;Xception提高5~8个百分点。 &ensp;&ensp;Loss降不下去时尝试调低LR！！！ &ensp;&ensp;降不下去就调小，调下的幅度一般是5倍、10倍左右，提高1~3个百分点。 &ensp;&ensp;TensorBoard监视训练状态！！！ &ensp;&ensp;尽可能使用Tensorflow提供的Tensorboard可视化工具，方便从宏观把控训练过程。 &ensp;&ensp;适度过拟合是良性的！！！ &ensp;&ensp;训练过程中一直没有过拟合，要从两方面考虑： 模型太简单，拟合能力不够，这时候要考虑提高网络复杂度 数据增强程度太大，导致某些特征学不到。 &ensp;&ensp;模型集成很重要！！！ &ensp;&ensp;“三个臭皮匠，顶个诸葛亮”，这句话还是很有道理的，千万不要单模型一条路跑到黑，要尝试将多个模型进行集成。集成的方式可以选择投票法、均值法、按照模型Acc加权法等等，提高0.5~1.5个百分点。 &ensp;&ensp;预测数据增强！！！ &ensp;&ensp;为了确保预测结果的准确性，可以将待预测结果进行水平翻转（或随机裁取patch等）处理，将这多张孪生图片进行预测，最终结果取多个结果的均值，提高0.25~1.0个百分点。 &ensp;&ensp;Teamwork is necessary!!! &ensp;&ensp;想法x2，时间/2，还能互相讨论学习！提高0~50个百分点！","categories":[{"name":"Events","slug":"Events","permalink":"http://winterfu.github.io/categories/Events/"}],"tags":[{"name":"AI,场景识别,Keras","slug":"AI-场景识别-Keras","permalink":"http://winterfu.github.io/tags/AI-场景识别-Keras/"}]},{"title":"剑指Offer(四)：树","slug":"剑指Offer-4：树","date":"2017-12-18T09:13:46.000Z","updated":"2017-12-18T09:26:59.204Z","comments":true,"path":"2017/12/18/剑指Offer-4：树/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-4：树/","excerpt":"摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重读数字。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp;输入某二叉树的前序遍历和中序遍历的结果，请重建出该二叉树。假设输入的前序遍历和中序遍历的结果中都不含重复的数字。例如输入前序遍历序列{1,2,4,7,3,5,6,8}和中序遍历序列{4,7,2,1,5,3,8,6}，则重建二叉树并返回。 1、思路&ensp;&ensp;这道题首先要明白二叉树的遍历方法，主要分为前序、中序和后序三种遍历方法以及三种遍历的特点，那么就不难解决这个问题了，下面我们来讲一下思路。&ensp;&ensp;先序遍历第一个位置肯定是根节点node， 中序遍历的根节点位置在中间p，在p左边的肯定是node的左子树的中序数组，p右边的肯定是node的右子树的中序数组；&ensp;&ensp;另一方面，先序遍历的第二个位置到p，也是node左子树的先序子数组，剩下p右边的就是node的右子树的先序子数组，把四个数组找出来，分左右递归调用即可。 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Definition for binary tree * struct TreeNode &#123; * int val; * TreeNode *left; * TreeNode *right; * TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125; * &#125;; */ class Solution &#123; public: struct TreeNode* reConstructBinaryTree(vector&lt;int&gt; pre,vector&lt;int&gt; in) &#123; int inlen=in.size(); if(inlen==0) return NULL; vector&lt;int&gt; left_pre,right_pre,left_in,right_in; //创建根节点，根节点肯定是前序遍历的第一个数 TreeNode* head=new TreeNode(pre[0]); //找到中序遍历根节点所在位置,存放于变量gen中 int gen=0; for(int i=0;i&lt;inlen;i++) &#123; if (in[i]==pre[0]) &#123; gen=i; break; &#125; &#125; //对于中序遍历，根节点左边的节点位于二叉树的左边，根节点右边的节点位于二叉树的右边 //利用上述这点，对二叉树节点进行归并 for(int i=0;i&lt;gen;i++) &#123; left_in.push_back(in[i]); left_pre.push_back(pre[i+1]);//前序第一个为根节点 &#125; for(int i=gen+1;i&lt;inlen;i++) &#123; right_in.push_back(in[i]); right_pre.push_back(pre[i]); &#125; //和shell排序的思想类似，取出前序和中序遍历根节点左边和右边的子树 //递归，再对其进行上述所有步骤，即再区分子树的左、右子子数，直到叶节点 head-&gt;left=reConstructBinaryTree(left_pre,left_in); head-&gt;right=reConstructBinaryTree(right_pre,right_in); return head; &#125; &#125;; &ensp;&ensp; 人生苦短，我用Python: 1234567891011121314151617181920# -*- coding:utf-8 -*-class TreeNode: def __init__(self, x): self.val = x self.left = None self.right = None class Solution: # 返回构造的TreeNode根节点 def reConstructBinaryTree(self, pre, tin): # write code here if len(pre) == 0: return None elif len(pre) == 1: return TreeNode(pre[0]) else: ans = TreeNode(pre[0]) ans.left = self.reConstructBinaryTree(pre[1:tin.index(pre[0])+1], tin[:tin.index(pre[0])]) ans.right = self.reConstructBinaryTree(pre[tin.index(pre[0])+1:], tin[tin.index(pre[0])+1:]) return ans","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"树,重建","slug":"树-重建","permalink":"http://winterfu.github.io/tags/树-重建/"}]},{"title":"剑指Offer(三)：链表","slug":"剑指Offer-3：链表","date":"2017-12-18T08:57:14.000Z","updated":"2017-12-18T09:12:18.703Z","comments":true,"path":"2017/12/18/剑指Offer-3：链表/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-3：链表/","excerpt":"摘要：输入一个链表，从尾到头打印链表每个节点的值。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网","text":"摘要：输入一个链表，从尾到头打印链表每个节点的值。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台：牛客网 二、题目&ensp;&ensp; 输入一个链表，从尾到头打印链表每个节点的值。 1、思路&ensp;&ensp;这道题目比较简单，但是用普通的循环肯定很难解决，因为链表的存储空间不是紧挨着的，我们可以定义两个向量，从头走到尾分别把每个节点对应的值存下来，求出向量的长度，然后利用循环将上一个向量中的元素逆序存入这个数组，最后返回即可。&ensp;&ensp;还有一种思路就是只使用一个向量，用一下C++高级容器中的反向迭代器 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031# two vectorsclass Solution&#123;public: vector &lt;int&gt; arr1, arr2; while(head != NULL)&#123; //cout&lt;&lt;head-&gt;val&lt;&lt;endl; arr1.push_back(head-&gt;val); head = head-&gt;next; &#125; for(int i = 0; i &lt; arr1.size(); i++)&#123; arr2.push_back(arr1[arr1.size()-1-i]); cout&lt;&lt;arr2[i]&lt;&lt;endl; &#125; return arr2;&#125;;# one vectorclass Solution &#123;public: vector&lt;int&gt; printListFromTailToHead(ListNode* head) &#123; vector&lt;int&gt; v; ListNode *p = head; while (p != nullptr) &#123; v.push_back(p-&gt;val); p = p-&gt;next; &#125; //反向迭代器创建临时对象 return vector&lt;int&gt;(v.rbegin(), v.rend()); &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"链表，剑指Offer","slug":"链表，剑指Offer","permalink":"http://winterfu.github.io/tags/链表，剑指Offer/"}]},{"title":"剑指Offer(二）：替换空格","slug":"剑指Offer-2：替换空格","date":"2017-12-18T08:38:29.000Z","updated":"2017-12-18T09:11:40.065Z","comments":true,"path":"2017/12/18/剑指Offer-2：替换空格/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-2：替换空格/","excerpt":"摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台： 牛客网","text":"摘要：请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 一、前言&ensp;&ensp;剑指Offer的刷题笔记。&ensp;&ensp;刷题平台： 牛客网 二、题目&ensp;&ensp; 请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。 1、思路&ensp;&ensp;最简单的方法就是从头到尾遍历，但是时间复杂度为O（n^2)。&ensp;&ensp;另外一种是：先遍历一次字符串，记录下字符串的长度和空格的数量，这样我们就可以得到新的字符串的总长度了。每替换一个空格，长度增加2，因此替换以后字符串的长度等于原来的长度加上2乘以空格数目。以”We are happy”为例，”We are happy”这个字符串的长度为14（包括结尾符号”\\n”），里面有两个空格，因此替换之后字符串的长度是18。很简单我们直接使用指针去做就好了，还有一点比较重要的就是注意字符串末尾的”\\0”. 2、具体实现&ensp;&ensp; C/C++: 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;using namespace std;//length为系统规定字符串输出的最大长度，固定为一个常数class Solution &#123;public: void replaceSpace(char *str, int length)&#123; int blankNumber = 0; //空格的数量 int oldstringLen; //记录原字符串的长度 //首先遍历原字符串，找出字符串的长度以及其中的空格数量 for (oldstringLen = 0; str[oldstringLen] != '\\0'; oldstringLen++)&#123; if (str[oldstringLen] == ' ') blankNumber++; &#125; //根据原字符串的长度和空格的数量我们可以求出最后新字符串的长度 int newstringLen = oldstringLen + blankNumber * 2; //新字符串的长度 if (newstringLen&gt;length) return; str[newstringLen] = '\\0'; //此行很重要，因为原字符串最后一个字符为'\\0' //设置两个指针point1和point2分别指向原字符串和新字符串的末尾位置 int point1 = oldstringLen - 1, point2 = newstringLen - 1; //因为'\\0'已经手工加到最后新串的最后一个字符，所以减1咯 while (point1 &gt;= 0 &amp;&amp; point2&gt;point1)&#123; //两指针相同时，跳出循环 if (str[point1] == ' ')&#123; //如果point1指向为空格，那么从point2开始赋值“02%” str[point2--] = '0'; str[point2--] = '2'; str[point2--] = '%'; &#125; else //如果point1指向内容不为空格，那么将内容赋值给point2指向的位置 str[point2--] = str[point1]; point1--; //不管是if还是else都要把point1前移,为了下一次的执行 &#125; &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"字符串，查找，替换","slug":"字符串，查找，替换","permalink":"http://winterfu.github.io/tags/字符串，查找，替换/"}]},{"title":"剑指Offer(一)：二维数组的查找","slug":"剑指Offer-1：二维数组的查找","date":"2017-12-18T07:53:37.000Z","updated":"2017-12-18T09:11:37.990Z","comments":true,"path":"2017/12/18/剑指Offer-1：二维数组的查找/","link":"","permalink":"http://winterfu.github.io/2017/12/18/剑指Offer-1：二维数组的查找/","excerpt":"摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 一、前言&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。刷题平台： 牛客网","text":"摘要：在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 一、前言&ensp;&ensp; 由于博主最近接下来要准备找工作，所以接下来一系列的文章都是针对刷题笔记和查漏补缺的记录，这样可以以后忘记了很方便的查找，下面的文章主要是针对剑指Offer的刷题笔记。刷题平台： 牛客网 二、题目&ensp;&ensp; 在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。 1、思路&ensp;&ensp;两种思路，一种是：把每一行看成有序递增的数组，利用二分查找，通过遍历每一行找到答案，时间复杂度是nlogn。&ensp;&ensp;另外一种是：每次将二维数组矩阵的中最右上角(或者左下角）的数字与要查找的数字比较，基于二维数组从左到右从上到下递增，那么当最右上角的数字大于目标数字就可以去掉该列，当最右边的数字小于目标数字的时候就去掉该行，如此遍历查找。 2、举例&ensp;&ensp; 如果在一个二维数组中找到数字7那么就返回True，否则返回False，这里我们只对第二种方法进行演示。&ensp;&ensp; 查找过程如下： 3、具体实现&ensp;&ensp; C/C++: 1234567891011121314151617181920public class Solution &#123; boolean Find(vector&lt;vector&lt;int&gt; &gt; array, int target) &#123; int rows = array.size(); int cols = array[0].size(); if(!array.empty() &amp;&amp; rows &gt; 0 &amp;&amp; cols &gt;0)&#123; int row = 0; int col = cols -1; while(row &lt; rows &amp;&amp; col &gt;= 0)&#123; if(target == array[row][col]) return true; else if(target&gt;array[row][col]) --col; else ++row; &#125; &#125; return false; &#125;&#125;;","categories":[{"name":"算法基础","slug":"算法基础","permalink":"http://winterfu.github.io/categories/算法基础/"}],"tags":[{"name":"数组，查找","slug":"数组，查找","permalink":"http://winterfu.github.io/tags/数组，查找/"}]},{"title":"那些让整个人都通透了的回复","slug":"那些让整个人都通透了的回复","date":"2017-11-30T02:54:52.000Z","updated":"2017-11-30T07:32:08.912Z","comments":true,"path":"2017/11/30/那些让整个人都通透了的回复/","link":"","permalink":"http://winterfu.github.io/2017/11/30/那些让整个人都通透了的回复/","excerpt":"1、交朋友的标准是什么？答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？答：一辈子都要和别人去比较，是人生悲剧的源头。","text":"1、交朋友的标准是什么？答：出世的智者，入世的强者，或者正常而阳光的普通人。 2、男性更看重女性的身材、脸蛋，还是思想？答：脸蛋和身材决定了我是否想去了解她的思想，思想决定了我是否会一票否决掉她的脸蛋和身材。 3、“别让孩子输在起跑线上”有道理吗？答：一辈子都要和别人去比较，是人生悲剧的源头。 4、做哪些事情可以提升生活品质？答：定期扔东西。 5、结婚以后两个人在一起最重要的是什么？答：就当这婚还没结。 6、怎么反驳“你行你上啊”的逻辑？答：“我评论个电冰箱，自己还得会制冷啊？” 7、把学费拿来念书还是环游世界更合适？为什么？答：读书在没有充分的知识作为前提的情况下，即使行了万里路也不过是邮差而已。 8、为什么部分人会产生“聪明智慧的姑娘都被憨憨的小伙儿搞定了”的印象？答：严肃地说，我觉得，要么姑娘只是看起来聪明，要么小伙儿只是看起来憨…… 9、你心中的完美爱情是怎么样的？答：可以有不完美。 10、异国长期生活，改变了你的哪些“是非观”？答：很多事情只是不同，并无是非。 11、是不是一个人越成熟就越难爱上一个人？答：不是越成熟越难爱上一个人。是越成熟，越能分辨那是不是爱。 12、如何让这个世界变得美好？答：把你自己变得更美好。 13、苦难有什么价值？答：永远不要相信苦难是值得的，苦难就是苦难，苦难不会带来成功。苦难不值得追求，磨练意志是因为苦难无法躲开。 14、如何反驳“现实点，这个社会就是这样”？答：“你是怎样，你的世界就是怎样。” 15、你对自由的理解是什么？答：说“不”的能力。 16、怎么看待励志的书籍？答：看再多，那都是别人的人生。 17、同样是别人比自己强，为什么有时会产生嫉妒心理，而有时会产生崇拜？答：远的崇拜，近的嫉妒；够不着的崇拜，够得着的嫉妒；有利益冲突的嫉妒，没利益冲突的崇拜。 18、为什么当看到好照片时人们通常的反应是“真不错，你用的是什么相机”，当看到烂照片时，则往往笑话拍摄者水平很臭？答：人习惯性地将自己的成功归因于自身，失败归因于环境；而将他人的成功归因于环境，失败归因于其自身。 19、怎样在有效提出推荐或建议的同时，避免给人灌输和强迫的感觉？答：说服他人不要诉诸理性，应求于利益。 20、哪些技能，经较短时间的学习，就可以给人的生活带来巨大帮助？答：夸奖他人。 21、你是如何走出人生的阴霾的？答：多走几步。 22、二十六岁，工作三年却将留学三年，值得吗？答：普通玩家选择标准配置，高端玩家选择自定义配置。 23、如何看待“年轻时就释怀与淡泊，是没有希望的”这句话？答：试图用一句话就来总结复杂的人生，是没有希望的。 24、要怎样努力，才能成为很厉害的人？答：如果你注定要成为厉害的人，那问题的答案就深藏在你的血脉里；如果你注定不是厉害的人，那你便只需要做好你自己。 25、前半生与后半生的分界线是在哪里？答：此时此刻。 26、你遇到过哪些让你眼前一亮、醍醐灌顶或对你改变很大的理念？答：天赋决定了你能达到的上限，努力程度决定了你能达到的下限。以绝大多数人的努力程度之低，远远没有达到要去拼天赋的地步。 27、人这一生为什么要努力？答：最痛苦的事，不是失败，是我本可以。 28、在一个足够小的星球上行走，我们是在上坡还是下坡？答：你感觉累就是上坡，感觉轻松就是下坡。 29、听过最落寞的一句话或诗句是什么？答：不如意事常八九，可与言者无二三。 30、世界上有那么多好书好电影好动漫注定看不完，我们对这个事实该持何种态度？答：怕什么真理无穷，进一寸有一寸的欢喜。——胡适 31、三十岁才开始学习编程靠谱吗？答：种一棵树最好的时间是十年前，其次是现在。 32、向喜欢的女生表白被拒绝了，还是喜欢她，怎么办？答：也许你弄错了什么是表白，表白应该是最终胜利时的号角，而不应该是发起进攻的冲锋号。 33、省钱的好办法有哪些？答：在买任何东西之前牢记九字箴言：你喜欢，你需要，你适合。PS：适用于很多事，包括感情也一样。 34、王阳明的“知行合一”到底如何理解？又怎样运用到实际生活中？答：知道做不到，等于不知道。 35、什么叫见过大世面？答：能享受最好的，能承受最坏的。 36、科学和迷信的分界点是哪里？答：我错了。 37、扎克伯格初期是怎么保护 Facebook 的最初创意？为什么Facebook 上线后没被其他大公司抄走？答：保护创意的最好方法，就是将其最好地执行。 38、员工辞职最主要的原因是什么？答：钱少事多离家远，位低权轻责任重。 39、你在生活中得到过的最好的建议是什么？答：“过度自我关注是万恶之源”、“永远不要为尚未发生的事儿拧巴”、“觉得为时已晚的时候，恰恰是最早的时候”。 40、哪些行为是浪费时间？答：思而不学+犹豫不决。 41、最能燃起你学习激情的一句话是什么？答：你不能把这个世界，让给你所鄙视的人。 42、如果好人没好报，我们为什么还要做好人？答：我们坚持一件事情，并不是因为这样做了会有效果，而是坚信，这样做是对的。——哈维尔 43、恋爱半年，女朋友觉得没有了开始时的新鲜感，怎么办？答：所谓新鲜感，不是和未知的人一起去做同样的事情，而是和已知的人一起去体验未知的人生。 44、为什么大家都要上大学找工作，而不太喜欢开出租车、开小店、开饭馆、摆街边早餐小吃摊等“短平快”项目？答：“孩子，我要求你读书用功，不是因为我要你跟别人比成绩，而是因为，我希望你将来会拥有选择的权利，选择有意义、有时间的工作，而不是被迫谋生。当你的工作在你心中有意义，你就有成就感。当你的工作给你时间，不剥夺你的生活，你就有尊严。成就感和尊严，给你快乐。”——龙应台 45、情商不高的例子有哪些？答：对陌生人毕恭毕敬，对亲近的人随意发怒…… 46、如何看待“年轻的时候需要的是朋友而不是人脉”？答：没有目的之交往，才能感动人。 47、有哪些道理是你读了不信，听不进去，直到你亲身经历方笃信不疑的？答：不要低估你的能力，不要高估你的毅力。 48、有哪些我们熟知的名言其实还有后半句？答：“人是生而自由的”，下一句是：“但无往不在枷锁之中”，再下一句是：“自以为是其他一切主人的人，反而比其他一切更是奴隶。”","categories":[{"name":"生活随想","slug":"生活随想","permalink":"http://winterfu.github.io/categories/生活随想/"}],"tags":[{"name":"生活，小情趣，大道理","slug":"生活，小情趣，大道理","permalink":"http://winterfu.github.io/tags/生活，小情趣，大道理/"}]},{"title":"那些年使用Git走过的坑","slug":"那些年使用Git走过的坑","date":"2017-11-28T13:43:31.000Z","updated":"2017-11-30T07:32:45.798Z","comments":true,"path":"2017/11/28/那些年使用Git走过的坑/","link":"","permalink":"http://winterfu.github.io/2017/11/28/那些年使用Git走过的坑/","excerpt":"Git介绍&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。&ensp;&ensp;下面就来介绍一下Git的工作流程： &ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。","text":"Git介绍&ensp;&ensp;Git是一种世界上最先进的分布式版本管理系统（没有之一），特点就是高端、大气上档次。那么什么是版本控制呢，通俗一点说就是可以记录你对文件每一次改动的都进行记录。&ensp;&ensp;下面就来介绍一下Git的工作流程： &ensp;&ensp;可以看到主要分为工作区和版本库两大部分，其中工作区也就是我们本地的文件夹，版本库也就是Git的内部存储，也可以看作是电脑的硬盘。 &ensp;&ensp;可以看到，工作流程就是在工作区进行文件的修改，然后使用 git add 实现将修改推送到暂存区，但是这并不会被推送到版本库内。 &ensp;&ensp;最终需要通过 git commit 命令来对之前在暂存区内的更改，提交到版本库，然后就可以进行版本库到远端的传输。 Git的基本操作 如何实现将本地代码部署到GitHub上？ 1234567891. Github New Project 【ProjectName】（下称PN）2. Copy PN的git地址3. 切到本地终端，cd到Project下4. git init5. git remote add origin 【Copy的url】6. git add .7. git commit -m \"Init Project\"8. git pull —rebase origin master（Github上New Project的时候如果初始化了READ.MD就要走这一步，否则不用；默认不会初始化的）9. git push origin master 如何将别人GitHub上的工程下载下来然后自己修改后再上传上去？ 12345671. git clone URL 到本地2. 修改了本地的a.py文件3. git add .4. git commit -m \"update a.py\" # 是为了将改动提交到本地git5. git pull —rebase origin master # 是为了拉远端代码到本地6. git push origin master # 是为了推本地代码到远端注意第5步，之所以要进行，是因为可能你改动a.py的同时，我也改动了a.py，然后我比你先推上去这个时候你如果不pull远端的代码就直接覆盖了。 如何回退到之前的版本，并实现远端和本地的回退？ 12345671.git status2. git pull —rebase origin master3. git status4. git log #找出你要回退的commit ID 5. #git reset —hard [上一步的commitID] 当然也可以使用 --hard HEAD^ 来逐个查询6. git status #执行完此步后可以看你的文件是不是返回到了修改之前7. git push origin master -f #如果不强推可以实现那就不用加 -f 更多重要的内容可以参照廖雪峰的Git教程，这样将有助于更好的了解Git的相关知识，让你更便捷的管理你的文件。","categories":[{"name":"教程","slug":"教程","permalink":"http://winterfu.github.io/categories/教程/"}],"tags":[{"name":"Git,Github","slug":"Git-Github","permalink":"http://winterfu.github.io/tags/Git-Github/"}]},{"title":"Python中关于str（）函数和repr（）函数的那些事","slug":"Python中关于str（）函数和repr（）函数的那些事","date":"2017-11-28T13:34:40.000Z","updated":"2017-11-30T07:37:21.073Z","comments":true,"path":"2017/11/28/Python中关于str（）函数和repr（）函数的那些事/","link":"","permalink":"http://winterfu.github.io/2017/11/28/Python中关于str（）函数和repr（）函数的那些事/","excerpt":"相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。 Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。","text":"相信很多小伙伴跟我一样，对于Python中的str函数和repr函数，有很多地方都是很不解，博主也是这样，于是决定从最开始的文档，然后一个一个print去看结果然后，就这样一直print，print总算是大致上理解其区别，话不多少直接上例子。 Python中的str( )和repr( )两个函数的区别，都是可以将任意的值转化为字符串：函数str( )将其转化成为适于人阅读的形式，而repr(object)就是转换成为阅读器阅读的形式， 返回一个可以用来表示对象的可打印字符串，用eval( )函数还可以返回相应的对象，下面直接上例子来说明这两个函数的用法。 对于字符串： a = ‘hello, world!\\n’12345678910&gt;&gt;&gt; a&apos;hello, world!\\n&apos; #输出的a本来的模样&gt;&gt;&gt; print(a) #对a经过加工后输出，将转义字符进行转义hello,world!&gt;&gt;&gt; print(str(a)) #可以看到对str返回的值进行print处理，这将与直接print（a）得到相同的结果hello,world! &gt;&gt;&gt; repr(a) #获得一种机器阅读的形式，也就是这个变量背地里是什么样子的。&quot;&apos;hello, world!\\n&apos;&quot;&gt;&gt;&gt; print(repr(a)) #对于repr返回的值进行print处理，可以看到这与直接在终端输入a，得到的是相同的结果&apos;hello,world!\\n&apos; 以上就是最基本的在字符串的显示中的使用，对应指令和输出结果及注释相信大家很容易都能看明白，接下来说一下这两个函数另外的作用。 ###在类中的使用，可以定义一些在实例运行时，控制repr()函数作用在其实例上时的行为。 123456789101112131415class test(object): def __init__(self, data): self.data = data仅仅是这样的话我们进行如下操作：&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; t&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; print(t)&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; str(t)&apos;&lt;__main__.test at 0x4db85f8&gt;&apos;&gt;&gt;&gt; repr(t)&apos;&lt;__main__.test at 0x4db85f8&gt;&apos; 在类中没有方法的时候，如果直接在终端输入类的实例，不会输出任何东西的，上面显示的内容是由于类的特殊方法（基本定制型）有str()和repr()， 在print(object)和直接运行实例的时候回打印字符串。如果没有实现（覆盖）该函数，就会出现上面的结果。 那我们定义一个str函数来看看效果： 123456789101112131415class test(object): def __init__(self, data): self.data = data def __str__(self): return &quot;ss&quot;&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; t&lt;__main__.test at 0x4db85f8&gt;&gt;&gt;&gt; str(t)&apos;ss&apos;&gt;&gt;&gt;print(t)ss&gt;&gt;&gt;repr(t)&lt;__main__.test at 0x4db85f8&gt; 可以看到在这里直接输入t还会跟上面的例子的结果一致，但是str（t）和print(t)已经发生了改变，不难看出显示的是我们在类中定义的str()函数的返回值，而rerp(t)还是 跟上个例子一样，下面我们也来实现一个str()函数来看一看效果。 1234567891011121314151617181920class test(object): def __init__(self, data): self.data = data def __str__(self): return &quot;ss&quot; def __repr__(self): return &quot;gg&quot;&gt;&gt;&gt; t = test(100)&gt;&gt;&gt; tgg&gt;&gt;&gt; str(t)&apos;ss&apos;&gt;&gt;&gt;print(t)ss&gt;&gt;&gt;repr(t)&apos;gg&apos;&gt;&gt;&gt; print(repr(t))gg 好了，可以很清楚的明白，默认的str() repr()函数与重构后的区别，以及这两者与直接输入和经过print处理以后的关系了吧。也就是直接在终端输入对象，相当于调用print（repr(oblect))函数，如果没有被复写则会出现上面最开始的那种显示形式；而print(object)函数相当于调用了print(str(object))这个函数，如果没有被复写就是使用的默认的，也会出现上面的显示结果。 下面还有一个对于repr( )函数的说明：Python中这个repr函数，对应repr(object)这个函数，返回一个可以用来表示对象的可打印字符串： 1.尝试生成这样一个字符串，将其传给 eval()可重新生成同样的对象 ；2.否则，生成用尖括号包住的字符串，包含类型名和额外的信息(比如地址) ；3.一个类(class)可以通过 repr() 成员来控制repr()函数作用在其实例上时的行为。 Python中，有的操作符和函数是做同样的事情，原因是某些场合下函数会比操作符更适合使用，比如函数对象可作为参数传递。 希望我的文章能够帮到你，喜欢的可以点一波关注！！您的支持是博主坚持的动力~~~","categories":[{"name":"python学习","slug":"python学习","permalink":"http://winterfu.github.io/categories/python学习/"}],"tags":[{"name":"python,str,repr","slug":"python-str-repr","permalink":"http://winterfu.github.io/tags/python-str-repr/"}]}]}